# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from .polymarket_async import polymarket
from ccxt.async_support.base.ws.cache import ArrayCache, ArrayCacheBySymbolById
from ccxt.base.types import Any, Int, Order, OrderBook, Str, Ticker, Trade
from ccxt.async_support.base.ws.client import Client
from typing import List
from ccxt.base.errors import ArgumentsRequired


class polymarket(polymarket):

    def describe(self) -> Any:
        return self.deep_extend(super(polymarket, self).describe(), {
            'has': {
                'ws': True,
                'watchBalance': False,
                'watchTicker': True,
                'watchTickers': False,
                'watchTrades': True,
                'watchTradesForSymbols': False,
                'watchMyTrades': True,
                'watchOrders': True,
                'watchOrderBook': True,
                'watchOHLCV': False,
            },
            'urls': {
                'api': {
                    'ws': {
                        'market': 'wss://ws-subscriptions-clob.polymarket.com/ws/market',
                        'user': 'wss://ws-subscriptions-clob.polymarket.com/ws/user',
                        'liveData': 'wss://ws-live-data.polymarket.com',
                    },
                },
            },
            'options': {
                'watchOrderBook': {
                    'channel': 'book',
                },
            },
            'streaming': {
            },
        })

    async def watch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        """
        watches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int [limit]: the maximum amount of order book entries to return
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.asset_id]: the asset ID for the specific outcome(required if market has multiple outcomes)
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
        """
        await self.load_markets()
        market = self.market(symbol)
        marketInfo = self.safe_dict(market, 'info', {})
        clobTokenIds = self.safe_value(marketInfo, 'clobTokenIds', [])
        assetId = self.safe_string_2(params, 'asset_id', 'token_id')  # Support both for backward compatibility
        # If asset_id not provided, use first token ID from market
        if assetId is None:
            if isinstance(clobTokenIds, list) and len(clobTokenIds) > 0:
                assetId = clobTokenIds[0]
            else:
                raise ArgumentsRequired(self.id + ' watchOrderBook() requires asset_id parameter when market has multiple outcomes')
        url = self.urls['api']['ws']['market']
        messageHash = 'orderbook:' + symbol + ':' + assetId
        request: dict = {
            'type': 'MARKET',
            'assets_ids': [assetId],
        }
        subscription: dict = {
            'symbol': symbol,
            'asset_id': assetId,
        }
        orderbook = await self.watch(url, messageHash, request, messageHash, subscription)
        return orderbook.limit(limit)

    async def watch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        get the list of most recent trades for a particular symbol
        :param str symbol: unified symbol of the market to fetch trades for
        :param int [since]: timestamp in ms of the earliest trade to fetch
        :param int [limit]: the maximum amount of trades to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.asset_id]: the asset ID for the specific outcome(required if market has multiple outcomes)
        :returns dict[]: a list of `trade structures <https://docs.ccxt.com/#/?id=public-trades>`
        """
        await self.load_markets()
        market = self.market(symbol)
        marketInfo = self.safe_dict(market, 'info', {})
        clobTokenIds = self.safe_value(marketInfo, 'clobTokenIds', [])
        assetId = self.safe_string_2(params, 'asset_id', 'token_id')  # Support both for backward compatibility
        # If asset_id not provided, use first token ID from market
        if assetId is None:
            if isinstance(clobTokenIds, list) and len(clobTokenIds) > 0:
                assetId = clobTokenIds[0]
            else:
                raise ArgumentsRequired(self.id + ' watchTrades() requires asset_id parameter when market has multiple outcomes')
        url = self.urls['api']['ws']['market']
        messageHash = 'trades:' + symbol + ':' + assetId
        request: dict = {
            'type': 'MARKET',
            'assets_ids': [assetId],
        }
        subscription: dict = {
            'symbol': symbol,
            'asset_id': assetId,
        }
        trades = await self.watch(url, messageHash, request, messageHash, subscription)
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(trades, symbol, since, limit, True)

    async def watch_ticker(self, symbol: str, params={}) -> Ticker:
        """
        watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.asset_id]: the asset ID for the specific outcome(required if market has multiple outcomes)
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        marketInfo = self.safe_dict(market, 'info', {})
        clobTokenIds = self.safe_value(marketInfo, 'clobTokenIds', [])
        assetId = self.safe_string_2(params, 'asset_id', 'token_id')  # Support both for backward compatibility
        # If asset_id not provided, use first token ID from market
        if assetId is None:
            if isinstance(clobTokenIds, list) and len(clobTokenIds) > 0:
                assetId = clobTokenIds[0]
            else:
                raise ArgumentsRequired(self.id + ' watchTicker() requires asset_id parameter when market has multiple outcomes')
        url = self.urls['api']['ws']['market']
        messageHash = 'ticker:' + symbol + ':' + assetId
        request: dict = {
            'type': 'MARKET',
            'assets_ids': [assetId],
        }
        subscription: dict = {
            'symbol': symbol,
            'asset_id': assetId,
        }
        return await self.watch(url, messageHash, request, messageHash, subscription)

    async def watch_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        watches information on an order made by the user
        :param str [symbol]: unified symbol of the market the order was made in
        :param int [since]: timestamp in ms of the earliest order to watch
        :param int [limit]: the maximum amount of orders to watch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.authenticate(params)
        messageHash = 'orders'
        url = self.urls['api']['ws']['user']
        request: dict = {
            'type': 'USER',
        }
        if symbol is not None:
            symbol = self.safe_symbol(symbol)
            messageHash = messageHash + ':' + symbol
            market = self.market(symbol)
            marketInfo = self.safe_dict(market, 'info', {})
            conditionId = self.safe_string(marketInfo, 'condition_id', market['id'])
            if conditionId is not None:
                request['markets'] = [conditionId]
        orders = await self.watch(url, messageHash, request, messageHash)
        if self.newUpdates:
            limit = orders.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(orders, symbol, since, limit, True)

    async def watch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        get the list of trades associated with the user
        :param str [symbol]: unified symbol of the market to fetch trades for
        :param int [since]: timestamp in ms of the earliest trade to fetch
        :param int [limit]: the maximum amount of trades to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `trade structures <https://docs.ccxt.com/#/?id=public-trades>`
        """
        await self.authenticate(params)
        messageHash = 'myTrades'
        url = self.urls['api']['ws']['user']
        request: dict = {
            'type': 'USER',
        }
        if symbol is not None:
            symbol = self.safe_symbol(symbol)
            messageHash = messageHash + ':' + symbol
            market = self.market(symbol)
            marketInfo = self.safe_dict(market, 'info', {})
            conditionId = self.safe_string(marketInfo, 'condition_id', market['id'])
            if conditionId is not None:
                request['markets'] = [conditionId]
        trades = await self.watch(url, messageHash, request, messageHash)
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(trades, symbol, since, limit, True)

    def handle_order_book(self, client: Client, message):
        #
        # Market websocket order book event:
        #     {
        #         "event_type": "book",
        #         "asset_id": "0x...",
        #         "bids": [[price, size], ...],
        #         "asks": [[price, size], ...],
        #         "timestamp": 1234567890
        #     }
        #
        # Or array of events:
        #     [{...}, {...}]
        #
        messages = []
        if isinstance(message, list):
            messages = message
        else:
            messages = [message]
        for i in range(0, len(messages)):
            msg = messages[i]
            eventType = self.safe_string(msg, 'event_type')
            if eventType != 'book':
                continue
            assetId = self.safe_string(msg, 'asset_id')
            # Find symbol and asset_id from subscriptions
            symbol = None
            subscriptionAssetId = None
            subscriptionKeys = list(client.subscriptions.keys())
            for j in range(0, len(subscriptionKeys)):
                subscribeHash = subscriptionKeys[j]
                subscription = client.subscriptions[subscribeHash]
                if subscription != None:
                    subAssetId = self.safe_string_2(subscription, 'asset_id', 'token_id')  # Support both for backward compatibility
                    if subAssetId == assetId:
                        symbol = self.safe_string(subscription, 'symbol')
                        subscriptionAssetId = subAssetId
                        break
            if symbol is None:
                # Try to resolve from asset_id
                market = self.safe_market(assetId)
                symbol = market['symbol']
                subscriptionAssetId = assetId
            messageHash = 'orderbook:' + symbol + ':' + subscriptionAssetId
            if not (symbol in self.orderbooks):
                self.orderbooks[symbol] = self.order_book({})
            orderbook = self.orderbooks[symbol]
            # Polymarket docs use `buys`/`sells` with OrderSummary objects, but some payloads use `bids`/`asks`
            rawBids = self.safe_value_2(msg, 'bids', 'buys', [])
            rawAsks = self.safe_value_2(msg, 'asks', 'sells', [])
            bids = []
            bidLevels = self.to_array(rawBids)
            for j in range(0, len(bidLevels)):
                level = bidLevels[j]
                if isinstance(level, list):
                    bids.append(level)
                elif isinstance(level, dict):
                    price = self.safe_string(level, 'price')
                    size = self.safe_string(level, 'size')
                    if price is not None and size is not None:
                        bids.append([price, size])
            asks = []
            askLevels = self.to_array(rawAsks)
            for j in range(0, len(askLevels)):
                level = askLevels[j]
                if isinstance(level, list):
                    asks.append(level)
                elif isinstance(level, dict):
                    price = self.safe_string(level, 'price')
                    size = self.safe_string(level, 'size')
                    if price is not None and size is not None:
                        asks.append([price, size])
            rawTimestamp = self.safe_integer(msg, 'timestamp')
            timestamp = None
            if rawTimestamp is not None:
                if rawTimestamp > 1000000000000:
                    timestamp = rawTimestamp
                else:
                    timestamp = rawTimestamp * 1000
            datetime = None
            if timestamp is not None:
                datetime = self.iso8601(timestamp)
            snapshot = self.parse_order_book({'bids': bids, 'asks': asks}, symbol, timestamp)
            orderbook.reset(snapshot)
            orderbook['symbol'] = symbol
            orderbook['timestamp'] = timestamp
            orderbook['datetime'] = datetime
            client.resolve(orderbook, messageHash)

    def handle_trades(self, client: Client, message):
        #
        # Market websocket trade event:
        #     {
        #         "event_type": "trade",
        #         "asset_id": "0x...",
        #         "trade_id": "0x...",
        #         "price": "0.5",
        #         "size": "100",
        #         "side": "buy",
        #         "timestamp": 1234567890
        #     }
        #
        messages = []
        if isinstance(message, list):
            messages = message
        else:
            messages = [message]
        for i in range(0, len(messages)):
            msg = messages[i]
            eventType = self.safe_string(msg, 'event_type')
            if eventType != 'trade':
                continue
            assetId = self.safe_string(msg, 'asset_id')
            # Find symbol and asset_id from subscriptions
            symbol = None
            subscriptionAssetId = None
            subscriptionKeys = list(client.subscriptions.keys())
            for j in range(0, len(subscriptionKeys)):
                subscribeHash = subscriptionKeys[j]
                subscription = client.subscriptions[subscribeHash]
                if isinstance(subscription, dict):
                    subAssetId = self.safe_string_2(subscription, 'asset_id', 'token_id')  # Support both for backward compatibility
                    if subAssetId == assetId:
                        symbol = self.safe_string(subscription, 'symbol')
                        subscriptionAssetId = subAssetId
                        break
            if symbol is None:
                # Try to resolve from asset_id
                market = self.safe_market(assetId)
                symbol = market['symbol']
                subscriptionAssetId = assetId
            messageHash = 'trades:' + symbol + ':' + subscriptionAssetId
            stored = self.safe_value(self.trades, symbol)
            if stored is None:
                limit = self.safe_integer(self.options, 'tradesLimit', 1000)
                stored = ArrayCache(limit)
                self.trades[symbol] = stored
            market = self.market(symbol)
            trade = self.parse_trade(msg, market)
            # Normalize WS timestamp(Polymarket typically sends ms timestamps in WS payloads)
            rawTimestamp = self.safe_integer(msg, 'timestamp')
            wsTimestamp = None
            if rawTimestamp is not None:
                if rawTimestamp > 1000000000000:
                    wsTimestamp = rawTimestamp
                else:
                    wsTimestamp = rawTimestamp * 1000
            if wsTimestamp is not None:
                trade['timestamp'] = wsTimestamp
                trade['datetime'] = self.iso8601(wsTimestamp)
            stored.append(trade)
            client.resolve(stored, messageHash)

    def handle_ticker(self, client: Client, message):
        #
        # Market websocket ticker events:
        #     {
        #         "event_type": "price_change",
        #         "asset_id": "0x...",
        #         "price": "0.5",
        #         "timestamp": 1234567890
        #     }
        #     {
        #         "event_type": "last_trade_price",
        #         "asset_id": "0x...",
        #         "price": "0.5",
        #         "timestamp": 1234567890
        #     }
        #
        messages = []
        if isinstance(message, list):
            messages = message
        else:
            messages = [message]
        for i in range(0, len(messages)):
            msg = messages[i]
            eventType = self.safe_string(msg, 'event_type')
            if eventType != 'price_change' and eventType != 'last_trade_price':
                continue
            # `last_trade_price` is per-asset, but `price_change` can be a batch containing `price_changes[]`.
            # Docs: https://docs.polymarket.com/developers/CLOB/websocket/market-channel#price-change-message
            rawTimestamp = self.safe_integer(msg, 'timestamp')
            timestamp = None
            if rawTimestamp is not None:
                if rawTimestamp > 1000000000000:
                    timestamp = rawTimestamp
                else:
                    timestamp = rawTimestamp * 1000
            priceChanges = self.safe_value(msg, 'price_changes')
            updates: List[Any] = []
            if eventType == 'price_change' and isinstance(priceChanges, list):
                updates = priceChanges
            else:
                updates = [msg]
            for k in range(0, len(updates)):
                update = updates[k]
                assetId = self.safe_string(update, 'asset_id', self.safe_string(msg, 'asset_id'))
                if assetId is None:
                    continue
                # Find symbol and asset_id from subscriptions
                symbol = None
                subscriptionAssetId = None
                subscriptionKeys = list(client.subscriptions.keys())
                for j in range(0, len(subscriptionKeys)):
                    subscribeHash = subscriptionKeys[j]
                    subscription = client.subscriptions[subscribeHash]
                    if isinstance(subscription, dict):
                        subAssetId = self.safe_string_2(subscription, 'asset_id', 'token_id')  # Support both for backward compatibility
                        if subAssetId == assetId:
                            symbol = self.safe_string(subscription, 'symbol')
                            subscriptionAssetId = subAssetId
                            break
                if symbol is None:
                    # Try to resolve from asset_id
                    market = self.safe_market(assetId)
                    symbol = market['symbol']
                    subscriptionAssetId = assetId
                messageHash = 'ticker:' + symbol + ':' + subscriptionAssetId
                market = self.market(symbol)
                prev = self.safe_value(self.tickers, symbol, {})
                last = self.safe_number(update, 'price', self.safe_number(msg, 'price', self.safe_number(prev, 'last')))
                bid = self.safe_number(update, 'best_bid', self.safe_number(prev, 'bid', last))
                ask = self.safe_number(update, 'best_ask', self.safe_number(prev, 'ask', last))
                info = msg
                if eventType == 'price_change':
                    info = update
                datetime = None
                if timestamp is not None:
                    datetime = self.iso8601(timestamp)
                ticker: Ticker = {
                    'symbol': symbol,
                    'info': info,
                    'timestamp': timestamp,
                    'datetime': datetime,
                    'last': last,
                    'bid': bid,
                    'bidVolume': None,
                    'ask': ask,
                    'askVolume': None,
                    'high': None,
                    'low': None,
                    'open': None,
                    'close': last,
                    'previousClose': None,
                    'change': None,
                    'percentage': None,
                    'average': None,
                    'baseVolume': None,
                    'quoteVolume': None,
                    'vwap': None,
                    'indexPrice': None,
                    'markPrice': None,
                }
                self.tickers[symbol] = ticker
                client.resolve(ticker, messageHash)

    def handle_orders(self, client: Client, message):
        #
        # User websocket order event:
        #     {
        #         "event_type": "order",
        #         "order_id": "0x...",
        #         "asset_id": "0x...",
        #         "side": "buy",
        #         "price": "0.5",
        #         "size": "100",
        #         "status": "open",
        #         "timestamp": 1234567890
        #     }
        #
        eventType = self.safe_string(message, 'event_type')
        if eventType != 'order':
            return
        messageHash = 'orders'
        stored = self.orders
        if stored is None:
            limit = self.safe_integer(self.options, 'ordersLimit', 1000)
            stored = ArrayCacheBySymbolById(limit)
            self.orders = stored
        order = self.parse_order(message)
        rawTimestamp = self.safe_integer(message, 'timestamp')
        wsTimestamp = None
        if rawTimestamp is not None:
            if rawTimestamp > 1000000000000:
                wsTimestamp = rawTimestamp
            else:
                wsTimestamp = rawTimestamp * 1000
        if wsTimestamp is not None:
            order['timestamp'] = wsTimestamp
            order['datetime'] = self.iso8601(wsTimestamp)
        orderSymbols: dict = {}
        orderSymbols[order['symbol']] = True
        stored.append(order)
        unique = list(orderSymbols.keys())
        for i in range(0, len(unique)):
            symbol = unique[i]
            symbolSpecificMessageHash = messageHash + ':' + symbol
            client.resolve(stored, symbolSpecificMessageHash)
        client.resolve(stored, messageHash)

    def handle_my_trades(self, client: Client, message):
        #
        # User websocket trade event:
        #     {
        #         "event_type": "trade",
        #         "trade_id": "0x...",
        #         "asset_id": "0x...",
        #         "side": "buy",
        #         "price": "0.5",
        #         "size": "100",
        #         "timestamp": 1234567890
        #     }
        #
        eventType = self.safe_string(message, 'event_type')
        if eventType != 'trade':
            return
        messageHash = 'myTrades'
        stored = self.myTrades
        if stored is None:
            limit = self.safe_integer(self.options, 'tradesLimit', 1000)
            stored = ArrayCacheBySymbolById(limit)
            self.myTrades = stored
        trade = self.parse_trade(message)
        rawTimestamp = self.safe_integer(message, 'timestamp')
        wsTimestamp = None
        if rawTimestamp is not None:
            if rawTimestamp > 1000000000000:
                wsTimestamp = rawTimestamp
            else:
                wsTimestamp = rawTimestamp * 1000
        if wsTimestamp is not None:
            trade['timestamp'] = wsTimestamp
            trade['datetime'] = self.iso8601(wsTimestamp)
        tradeSymbols: dict = {}
        tradeSymbols[trade['symbol']] = True
        stored.append(trade)
        unique = list(tradeSymbols.keys())
        uniqueLength = len(unique)
        if uniqueLength == 0:
            return
        for i in range(0, len(unique)):
            symbol = unique[i]
            symbolSpecificMessageHash = messageHash + ':' + symbol
            client.resolve(stored, symbolSpecificMessageHash)
        client.resolve(stored, messageHash)

    def handle_message(self, client: Client, message):
        #
        # Market websocket messages can be:
        #     - Single event object: {"event_type": "book", ...}
        #     - Array of events: [{"event_type": "book", ...}, ...]
        #     - Ready event: {"event": "ready"} or similar(check Python code)
        #
        # User websocket messages:
        #     - Single event object: {"event_type": "order", ...}
        #
        # Check for ready event first(Polymarket may send self)
        event = self.safe_string(message, 'event')
        if event == 'ready' or event == 'connected':
            # Connection ready - subscriptions are sent automatically by base watch() method
            return
        if isinstance(message, list):
            # Handle array of events(market websocket)
            self.handle_market_events(client, message)
        else:
            eventType = self.safe_string(message, 'event_type')
            url = client.url
            # Determine which websocket based on URL
            if url.find('/ws/market') >= 0:
                # Market websocket
                self.handle_market_event(client, message, eventType)
            elif url.find('/ws/user') >= 0:
                # User websocket
                self.handle_user_event(client, message, eventType)
            elif url.find('ws-live-data') >= 0:
                # Live data websocket - not implemented yet
                if self.verbose:
                    self.log('Live data websocket message:', message)

    def handle_market_events(self, client: Client, messages: List[Any]):
        # Handle array of market events
        for i in range(0, len(messages)):
            msg = messages[i]
            eventType = self.safe_string(msg, 'event_type')
            self.handle_market_event(client, msg, eventType)

    def handle_market_event(self, client: Client, message: Any, eventType: str):
        if eventType == 'book':
            self.handle_order_book(client, message)
        elif eventType == 'trade':
            self.handle_trades(client, message)
        elif eventType == 'price_change' or eventType == 'last_trade_price':
            self.handle_ticker(client, message)
        elif eventType == 'tick_size_change':
            # Tick size change - can be used to update ticker
            if self.verbose:
                self.log('Tick size change event:', message)
        else:
            # Unknown event type, log but don't error
            if self.verbose:
                self.log('Unknown market websocket event type:', eventType, message)

    def handle_user_event(self, client: Client, message: Any, eventType: str):
        if eventType == 'order':
            self.handle_orders(client, message)
        elif eventType == 'trade':
            self.handle_my_trades(client, message)
        else:
            # Unknown event type, log but don't error
            if self.verbose:
                self.log('Unknown user websocket event type:', eventType, message)

    async def authenticate(self, params={}):
        url = self.urls['api']['ws']['user']
        client = self.client(url)
        messageHash = 'authenticated'
        future = self.safe_value(client.subscriptions, messageHash)
        if future is None:
            # Get API credentials
            creds = await self.ensureApiCredentials(params)
            # Build auth payload matching Python implementation
            # auth=creds.model_dump(by_alias=True) in Python becomes:
            auth: dict = {
                'apiKey': creds['apiKey'],
                'secret': creds['secret'],
                'passphrase': creds['passphrase'],
            }
            request: dict = {
                'auth': auth,
                'type': 'USER',
            }
            future = await self.watch(url, messageHash, request, messageHash)
            client.subscriptions[messageHash] = future
        return future

    async def watch(self, url: str, messageHash: str, message=None, subscribeHash=None, subscription=None):
        client = self.client(url)
        if subscribeHash is None:
            subscribeHash = messageHash
        # Store subscription info for market websocket to use in handleMessage
        if subscription is not None and url.find('/ws/market') >= 0:
            # Store subscription separately so we can look it up by asset_id
            if not (subscribeHash in client.subscriptions):
                client.subscriptions[subscribeHash] = subscription
        return await super(polymarket, self).watch(url, messageHash, message, subscribeHash, subscription)

    def on_connected(self, client: Client):
        # Called when websocket connection is established
        # The base watch() method will send the message automatically
        # But for Polymarket, we may need to wait for a "ready" event
        # For now, the base class handle it
        super(polymarket, self).on_connected(client)
