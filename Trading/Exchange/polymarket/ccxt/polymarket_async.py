# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from .polymarket_abstract import ImplicitAPI
import hashlib
import math
import json
import numbers
from ccxt.base.types import Any, Int, Market, MarketType, Num, Order, OrderBook, OrderRequest, OrderSide, OrderType, Str, Strings, Ticker, Tickers, OrderBooks, Trade, TradingFeeInterface
from typing import List
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NetworkError
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import OnMaintenance
from ccxt.base.decimal_to_precision import ROUND
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class polymarket(Exchange, ImplicitAPI):

    def describe(self) -> Any:
        return self.deep_extend(super(polymarket, self).describe(), {
            'id': 'polymarket',
            'name': 'Polymarket',
            'countries': ['US'],
            'version': '1',
            # Rate limits are enforced using Cloudflare's throttling system
            # Requests over the limit are throttled/delayed rather than rejected
            # See https://docs.polymarket.com/quickstart/introduction/rate-limits
            # Cost calculation formula: cost = (1000 / rateLimit) * 60 / requests_per_minute
            # With rateLimit = 50ms(20 req/s = 1200 req/min), base cost = 1.0
            # General limits:
            # - General Rate Limiting: 5000 requests / 10s(500 req/s = 30000 req/min) => cost = 0.04
            # - CLOB(General): 5000 requests / 10s(500 req/s = 30000 req/min) => cost = 0.04
            # - GAMMA(General): 750 requests / 10s(75 req/s = 4500 req/min) => cost = 0.267
            # - Data API(General): 200 requests / 10s(20 req/s = 1200 req/min) => cost = 1.0
            # Setting to 50ms(20 req/s) to match the most restrictive general limit(Data API)
            # Specific endpoint costs are calculated relative to self base rateLimit
            'rateLimit': 50,  # 20 requests per second(matches Data API general limit)
            'certified': False,
            'pro': True,
            'requiredCredentials': {
                'apiKey': False,
                'secret': False,
                'walletAddress': True,
                'privateKey': True,
            },
            'has': {
                'CORS': None,
                'spot': False,
                'margin': False,
                'swap': False,
                'future': False,
                'option': True,
                'addMargin': False,
                'cancelOrder': True,
                'cancelOrders': True,
                'createDepositAddress': True,  # TODO with https://docs.polymarket.com/developers/misc-endpoints/bridge-deposit
                'createMarketBuyOrderWithCost': False,
                'createMarketOrder': True,
                'createMarketOrderWithCost': False,
                'createMarketSellOrderWithCost': False,
                'createOrder': True,
                'createOrders': True,
                'createStopLimitOrder': False,
                'createStopMarketOrder': False,
                'createStopOrder': False,
                'editOrder': False,
                'fetchBalance': True,
                'fetchBorrowInterest': False,
                'fetchBorrowRateHistories': False,
                'fetchBorrowRateHistory': False,
                'fetchClosedOrders': False,
                'fetchCrossBorrowRate': False,
                'fetchCrossBorrowRates': False,
                'fetchCurrencies': False,
                'fetchDepositAddress': False, 
                'fetchDepositAddresses': True,  # TODO with https://docs.polymarket.com/developers/misc-endpoints/bridge-supported-assets
                'fetchDepositAddressesByNetwork': True,  # TODO with https://docs.polymarket.com/developers/misc-endpoints/bridge-supported-assets
                'fetchDeposits': False,
                'fetchFundingHistory': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': False,
                'fetchIndexOHLCV': False,
                'fetchIsolatedBorrowRate': False,
                'fetchIsolatedBorrowRates': False,
                'fetchLedger': False,
                'fetchLedgerEntry': False,
                'fetchLeverageTiers': False,
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenInterest': True,
                'fetchOpenInterestHistory': False,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrderBooks': True,
                'fetchOrders': True,
                'fetchPositionMode': False,
                'fetchPremiumIndexOHLCV': False,
                'fetchStatus': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': True,
                'fetchTradingFee': True,
                'fetchTradingFees': False,
                'fetchWithdrawals': False,
                'setLeverage': False,
                'setMarginMode': False,
                'transfer': False,
                'withdraw': False,
            },
            'urls': {
                'logo': 'https://polymarket.com/favicon.ico',
                'api': {
                    'gamma': 'https://gamma-api.polymarket.com',
                    'clob': 'https://clob.polymarket.com',  # Can be overridden with options.clobHost
                    'data': 'https://data-api.polymarket.com',
                    'bridge': 'https://bridge.polymarket.com',
                    'ws': 'wss://ws-subscriptions-clob.polymarket.com/ws/',  # CLOB WebSocket for subscriptions
                    'rtds': 'wss://ws-live-data.polymarket.com',  # Real Time Data Socket for crypto prices and comments
                },
                'test': {},  # TODO if exists
                'www': 'https://polymarket.com',
                'doc': [
                    'https://docs.polymarket.com',
                ],
                'fees': 'https://docs.polymarket.com/developers/CLOB/introduction',
            },
            'api': {
                # GAMMA API: https://gamma-api.polymarket.com
                # Rate limits: https://docs.polymarket.com/quickstart/introduction/rate-limits
                # Cost calculation: cost = (1000 / 50) * 60 / requests_per_minute = 1200 / requests_per_minute
                # - GAMMA(General): 750 requests / 10s(75 req/s = 4500 req/min) => cost = 0.267
                # - GAMMA Get Comments: 100 requests / 10s(10 req/s = 600 req/min) => cost = 2.0
                # - GAMMA /events: 100 requests / 10s(10 req/s = 600 req/min) => cost = 2.0
                # - GAMMA /markets: 125 requests / 10s(12.5 req/s = 750 req/min) => cost = 1.6
                # - GAMMA /markets /events listing: 100 requests / 10s(10 req/s = 600 req/min) => cost = 2.0
                # - GAMMA Tags: 100 requests / 10s(10 req/s = 600 req/min) => cost = 2.0
                # - GAMMA Search: 300 requests / 10s(30 req/s = 1800 req/min) => cost = 0.667
                'gamma': {
                    'public': {
                        'get': {
                            # Market endpoints
                            'markets': 1.6,                     # GET /markets - used by fetchMarkets(125 req/10s = 750 req/min)
                            'markets/{id}': 0.267,              # GET /markets/{id} - used by gammaPublicGetMarketsId(general limit)
                            'markets/{id}/tags': 2.0,            # GET /markets/{id}/tags - used by gammaPublicGetMarketsIdTags(100 req/10s = 600 req/min)
                            'markets/slug/{slug}': 0.267,        # GET /markets/slug/{slug} - used by gammaPublicGetMarketsSlugSlug(general limit)
                            # Event endpoints
                            'events': 2.0,                      # GET /events - used by gammaPublicGetEvents(100 req/10s = 600 req/min)
                            'events/{id}': 0.267,                # GET /events/{id} - used by gammaPublicGetEventsId(general limit)
                            # Series endpoints
                            'series': 0.267,                     # GET /series - used by gammaPublicGetSeries(general limit)
                            'series/{id}': 0.267,               # GET /series/{id} - used by gammaPublicGetSeriesId(general limit)
                            # Search endpoints
                            'search': 0.667,                     # GET /search - used by gammaPublicGetSearch(300 req/10s = 1800 req/min)
                            # Comment endpoints
                            'comments': 2.0,                     # GET /comments - used by gammaPublicGetComments(100 req/10s = 600 req/min)
                            'comments/{id}': 0.267,             # GET /comments/{id} - used by gammaPublicGetCommentsId(general limit)
                            # Sports endpoints
                            'sports': 0.267,                    # GET /sports - used by gammaPublicGetSports(general limit)
                            'sports/{id}': 0.267,               # GET /sports/{id} - used by gammaPublicGetSportsId(general limit)
                        },
                    },
                },
                # Data-API: https://data-api.polymarket.com
                # Rate limits: https://docs.polymarket.com/quickstart/introduction/rate-limits
                # Cost calculation: cost = (1000 / 50) * 60 / requests_per_minute = 1200 / requests_per_minute
                # - Data API(General): 200 requests / 10s(20 req/s = 1200 req/min) => cost = 1.0
                # - Data API(Alternative): 1200 requests / 1 minute(20 req/s = 1200 req/min) => cost = 1.0
                # - Data API /trades: 75 requests / 10s(7.5 req/s = 450 req/min) => cost = 2.67
                # - Data API "OK" Endpoint: 10 requests / 10s(1 req/s = 60 req/min) => cost = 20.0
                'data': {
                    'public': {
                        'get': {
                            # Core endpoints(from Data-API)
                            'positions': 1.0,                     # GET /positions - used by dataPublicGetPositions(200 req/10s = 1200 req/min)
                            'trades': 2.67,                      # GET /trades - used by dataPublicGetTrades(75 req/10s = 450 req/min)
                            'activity': 1.0,                      # GET /activity - used by dataPublicGetActivity(200 req/10s = 1200 req/min)
                            'holders': 1.0,                       # GET /holders - used by dataPublicGetHolders(200 req/10s = 1200 req/min)
                            'value': 1.0,                         # GET /value - used by dataPublicGetTotalValue(200 req/10s = 1200 req/min)
                            'closed-positions': 1.0,             # GET /closed-positions - used by dataPublicGetClosedPositions(200 req/10s = 1200 req/min)
                            # Misc endpoints(from Data-API)
                            'traded': 1.0,                        # GET /traded - used by dataPublicGetTraded(200 req/10s = 1200 req/min)
                            'oi': 1.0,                            # GET /oi - used by dataPublicGetOpenInterest(200 req/10s = 1200 req/min)
                            'live-volume': 1.0,                   # GET /live-volume - used by dataPublicGetLiveVolume(200 req/10s = 1200 req/min)
                        },
                    },
                },
                # Bridge API: https://bridge.polymarket.com
                # Rate limits: Not explicitly documented, using conservative general rate limits
                # Assuming similar to Data API: 200 requests / 10s(20 req/s = 1200 req/min) => cost = 1.0
                'bridge': {
                    'public': {
                        'get': {
                            # Bridge endpoints
                            'supported-assets': 1.0,              # GET /supported-assets - used by bridgePublicGetSupportedAssets(assumed 200 req/10s)
                        },
                        'post': {
                            # Bridge endpoints
                            'deposit': 1.0,                       # POST /deposit - used by bridgePublicPostDeposit(assumed 200 req/10s)
                        },
                    },
                },
                # CLOB API: https://clob.polymarket.com
                # Rate limits: https://docs.polymarket.com/quickstart/introduction/rate-limits
                # Cost calculation: cost = (1000 / 50) * 60 / requests_per_minute = 1200 / requests_per_minute
                # General CLOB Endpoints:
                # - CLOB(General): 5000 requests / 10s(500 req/s = 30000 req/min) => cost = 0.04
                # - CLOB GET Balance Allowance: 125 requests / 10s(12.5 req/s = 750 req/min) => cost = 1.6
                # - CLOB UPDATE Balance Allowance: 20 requests / 10s(2 req/s = 120 req/min) => cost = 10.0
                # CLOB Market Data:
                # - CLOB /book: 200 requests / 10s(20 req/s = 1200 req/min) => cost = 1.0
                # - CLOB /books: 80 requests / 10s(8 req/s = 480 req/min) => cost = 2.5
                # - CLOB /price: 200 requests / 10s(20 req/s = 1200 req/min) => cost = 1.0
                # - CLOB /prices: 80 requests / 10s(8 req/s = 480 req/min) => cost = 2.5
                # - CLOB /midprice: 200 requests / 10s(20 req/s = 1200 req/min) => cost = 1.0
                # - CLOB /midprices: 80 requests / 10s(8 req/s = 480 req/min) => cost = 2.5
                # CLOB Ledger Endpoints:
                # - CLOB Ledger(/trades /orders /notifications /order): 300 requests / 10s(30 req/s = 1800 req/min) => cost = 0.667
                # - CLOB Ledger /data/orders: 150 requests / 10s(15 req/s = 900 req/min) => cost = 1.33
                # - CLOB Ledger /data/trades: 150 requests / 10s(15 req/s = 900 req/min) => cost = 1.33
                # - CLOB /notifications: 125 requests / 10s(12.5 req/s = 750 req/min) => cost = 1.6
                # CLOB Markets & Pricing:
                # - CLOB Price History: 100 requests / 10s(10 req/s = 600 req/min) => cost = 2.0
                # - CLOB Markets: 250 requests / 10s(25 req/s = 1500 req/min) => cost = 0.8
                # - CLOB Market Tick Size: 50 requests / 10s(5 req/s = 300 req/min) => cost = 4.0
                # - CLOB markets/0x: 50 requests / 10s(5 req/s = 300 req/min) => cost = 4.0
                # - CLOB /markets listing: 100 requests / 10s(10 req/s = 600 req/min) => cost = 2.0
                # CLOB Authentication:
                # - CLOB API Keys: 50 requests / 10s(5 req/s = 300 req/min) => cost = 4.0
                # CLOB Trading Endpoints(using sustained limits, not BURST):
                # - CLOB POST /order: 24000 requests / 10 minutes(40 req/s = 2400 req/min) => cost = 0.5
                # - CLOB DELETE /order: 24000 requests / 10 minutes(40 req/s = 2400 req/min) => cost = 0.5
                # - CLOB POST /orders: 12000 requests / 10 minutes(20 req/s = 1200 req/min) => cost = 1.0
                # - CLOB DELETE /orders: 12000 requests / 10 minutes(20 req/s = 1200 req/min) => cost = 1.0
                # - CLOB DELETE /cancel-all: 3000 requests / 10 minutes(5 req/s = 300 req/min) => cost = 4.0
                # - CLOB DELETE /cancel-market-orders: 12000 requests / 10 minutes(20 req/s = 1200 req/min) => cost = 1.0
                'clob': {
                    'public': {
                        'get': {
                            # Order book endpoints
                            'orderbook': 1.0,                     # GET /book - used by fetchOrderBook(200 req/10s = 1200 req/min)
                            'orderbook/{token_id}': 0.04,        # Not used(deprecated format, general limit)
                            # Trade endpoints
                            'market/{condition_id}/trades': 0.04,  # Not used(deprecated, use /trades instead, general limit)
                            'trades': 0.667,                    # GET /data/trades - used by fetchTrades(300 req/10s = 1800 req/min)
                            # Price history endpoints
                            'prices-history': 2.0,              # GET /prices-history - used by fetchOHLCV(100 req/10s = 600 req/min)
                            # Pricing endpoints
                            'price': 1.0,                       # GET /price - available but using POST /prices instead(200 req/10s = 1200 req/min)
                            'prices': 2.5,                      # GET /prices - used by fetchTickers(80 req/10s = 480 req/min)
                            # Midpoint endpoints
                            'midpoint': 1.0,                    # GET /midpoint - used by fetchTicker(200 req/10s = 1200 req/min)
                            'midpoints': 2.5,                   # GET /midpoints - available for fetchTickers enhancement(80 req/10s = 480 req/min)
                            # Spread endpoints
                            'spread': 0.04,                     # GET /spread - available for fetchTicker enhancement(general limit)
                            # Last trade price endpoints
                            'last-trade-price': 0.04,           # GET /last-trade-price - available for ticker enhancement(general limit)
                            'last-trades-prices': 0.04,         # GET /last-trades-prices - available for tickers enhancement(general limit)
                            # Utility endpoints
                            '': 4.0,                            # GET / - health check endpoint used by fetchStatus/clobPublicGetOk(50 req/10s = 300 req/min)
                            'time': 0.04,                       # GET /time - used by fetchTime(general limit)
                            'tick-size': 4.0,                   # GET /tick-size - used for market precision(50 req/10s = 300 req/min)
                            'neg-risk': 0.04,                   # GET /neg-risk - used for market metadata(general limit)
                            'fee-rate': 0.04,                   # GET /fee-rate - used by fetchTradingFee(general limit)
                            'markets': 2.0,                     # GET /markets - used by fetchMarkets(100 req/10s = 600 req/min)
                        },
                        'post': {
                            # Order book endpoints
                            'books': 2.5,                      # POST /books - used by fetchOrderBooks(80 req/10s = 480 req/min)
                            # Spread endpoints
                            'spreads': 0.04,                    # POST /spreads - used by fetchTickers(optional, general limit)
                            # Pricing endpoints
                            'prices': 2.5,                      # POST /prices - used by fetchTicker(80 req/10s = 480 req/min)
                        },
                    },
                    'private': {
                        'get': {
                            # Order endpoints
                            'order': 0.667,                     # GET /data/order/{order_id} - used by fetchOrder(300 req/10s = 1800 req/min)
                            'orders': 1.33,                     # GET /data/orders - used by fetchOrders, fetchOpenOrders(150 req/10s = 900 req/min)
                            # Trade endpoints
                            'trades': 0.667,                    # GET /data/trades - used by fetchMyTrades(300 req/10s = 1800 req/min)
                            'builder-trades': 0.667,             # GET /builder-trades - used for builder trades(300 req/10s = 1800 req/min)
                            # Notification endpoints
                            'notifications': 1.6,                # GET /notifications - used by getNotifications(125 req/10s = 750 req/min)
                            # Balance endpoints
                            'balance-allowance': 1.6,           # GET /balance-allowance - used by fetchBalance/getBalanceAllowance(125 req/10s = 750 req/min)
                            # Order scoring endpoints
                            'order-scoring': 0.04,               # GET /order-scoring - used by isOrderScoring(general limit)
                            # API credential endpoints(L1 authentication - uses manual URL building)
                            'auth/derive-api-key': 4.0,         # GET /auth/derive-api-key - used by derive_api_key(50 req/10s = 300 req/min)
                        },
                        'post': {
                            # Order creation endpoints
                            'order': 0.5,                       # POST /order - used by createOrder(24000 req/10min = 2400 req/min sustained)
                            'orders': 1.0,                      # POST /orders - used by createOrders(12000 req/10min = 1200 req/min sustained)
                            # Order scoring endpoints
                            'orders-scoring': 0.04,             # POST /orders-scoring - used by areOrdersScoring(general limit)
                            # API credential endpoints
                            'auth/api-key': 4.0,                # POST /auth/api-key - used by create_or_derive_api_creds(50 req/10s = 300 req/min)
                        },
                        'delete': {
                            # Order cancellation endpoints
                            'order': 0.5,                       # DELETE /order - used by cancelOrder(24000 req/10min = 2400 req/min sustained)
                            'orders': 1.0,                      # DELETE /orders - used by cancelOrders(12000 req/10min = 1200 req/min sustained)
                            'cancel-all': 4.0,                   # DELETE /cancel-all - used by cancelAllOrders(3000 req/10min = 300 req/min sustained)
                            'cancel-market-orders': 1.0,        # DELETE /cancel-market-orders - used for canceling market orders(12000 req/10min = 1200 req/min sustained)
                            # Notification endpoints
                            'notifications': 0.04,               # DELETE /notifications - used by dropNotifications(general limit)
                        },
                        'put': {
                            # Balance endpoints
                            'balance-allowance': 10.0,           # PUT /balance-allowance - used by updateBalanceAllowance(20 req/10s = 120 req/min)
                        },
                    },
                },
            },
            'timeframes': {
                '1m': '1m',
                '1h': '1h',
                '6h': '6h',
                '1d': '1d',
                '1w': '1w',
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'taker': self.parse_number('0.02'),  # 2% taker fee(approximate)
                    'maker': self.parse_number('0.02'),  # 2% maker fee(approximate)
                },
            },
            'options': {
                'fetchMarkets': {
                    'active': True,  # only fetch active markets by default
                    'closed': False,
                    'archived': False,
                },
                'funder': None,  # Address that holds funds(walletAddress, required for proxy wallets like email/Magic wallets)
                'proxyWallet': None,  # Proxy wallet address for Data-API endpoints(defaults to funder/walletAddress if not set)
                'builderWallet': None,  # Builder wallet address(defaults to funder/walletAddress if not set)
                'signatureTypes': {
                    # https://docs.polymarket.com/developers/CLOB/orders/orders#signature-types
                    'EOA': 0,  # EIP712 signature signed by an EOA
                    'POLY_PROXY': 1,  # EIP712 signatures signed by a signer associated with funding Polymarket proxy wallet
                    'POLY_GNOSIS_SAFE': 2,  # EIP712 signatures signed by a signer associated with funding Polymarket gnosis safe wallet
                },
                'side': None,  # Order side: 'BUY' or 'SELL'(default: None, must be provided)
                'sides': {
                    'BUY': 0,  # Buy side(maker gives USDC, wants tokens)
                    'SELL': 1,  # Sell side(maker gives tokens, wants USDC)
                },
                'chainId': 137,  # Chain ID: 137 = Polygon mainnet(default), 80001 = Polygon Mumbai testnet
                'chainName': 'polygon-mainnet',  # Chain name: 'polygon-mainnet'(default), 'polygon-mumbai'(testnet)
                'sandboxMode': False,  # Enable sandbox/testnet mode(uses Polygon Mumbai testnet)
                'clobHost': None,  # Custom CLOB API endpoint(defaults to https://clob.polymarket.com)
                'defaultCollateral': 'USDC',  # Default collateral currency
                'defaultExpirationDays': 30,  # Default expiration in days(default: 30 days from now)
                'defaultFeeRateBps': 200,  # Default fee rate fallback in basis points(default: 200 bps = 2%)
                'defaultTickSize': '0.01',  # Default tick size for rounding config(default: 0.01 = 2 decimal places for price, 2 for size, 4 for amount)
                'marketOrderQuoteDecimals': 2,  # Max decimal places for quote currency(USDC) in market orders(default: 2)
                'marketOrderBaseDecimals': 4,  # Max decimal places for base currency(tokens) in market orders(default: 4)
                'roundingBufferDecimals': 4,  # Additional decimal places buffer for rounding up before final rounding down(default: 4)
                # Constants matching clob-client
                # See https://github.com/Polymarket/clob-client/blob/main/src/signing/constants.ts
                # See https://github.com/Polymarket/clob-client/blob/main/src/constants.ts
                'clobDomainName': 'ClobAuthDomain',
                'clobVersion': '1',
                'msgToSign': 'This message attests that I control the given wallet',
                'initialCursor': 'MA==',  # Base64 encoded empty string, matches clob-client INITIAL_CURSOR
                'endCursor': 'LTE=',  # Sentinel value indicating end of pagination
                'defaultTokenId': None,  # Default token ID for conditional tokens
                # Constants matching py-clob-client
                # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/constants.py
                'zeroAddress': '0x0000000000000000000000000000000000000000',  # Zero address for open orders(taker)
                # EIP-712 domain constants matching clob-order-utils
                # See https://github.com/Polymarket/clob-order-utils/blob/main/src/exchange.order.const.ts
                'orderDomainName': 'Polymarket CTF Exchange',  # EIP-712 domain name for orders(PROTOCOL_NAME)
                'orderDomainVersion': '1',  # EIP-712 domain version for orders(PROTOCOL_VERSION)
                # Contract addresses for all networks
                # See https://github.com/Polymarket/clob-client/blob/main/src/config.ts
                'contracts': {
                    # Polygon Amoy testnet(chainId: 80001)
                    '80001': {
                        'exchange': '0xdFE02Eb6733538f8Ea35D585af8DE5958AD99E40',
                        'negRiskAdapter': '0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296',
                        'negRiskExchange': '0xC5d563A36AE78145C45a50134d48A1215220f80a',
                        'collateral': '0x9c4e1703476e875070ee25b56a58b008cfb8fa78',
                        'conditionalTokens': '0x69308FB512518e39F9b16112fA8d994F4e2Bf8bB',
                    },
                    # Polygon mainnet(chainId: 137)
                    '137': {
                        'exchange': '0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E',
                        'negRiskAdapter': '0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296',
                        'negRiskExchange': '0xC5d563A36AE78145C45a50134d48A1215220f80a',
                        'collateral': '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',
                        'conditionalTokens': '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045',
                    },
                },
            },
            'exceptions': {
                'exact': {
                    # HTTP status codes
                    '400': BadRequest,  # Bad Request - Invalid request parameters
                    '401': AuthenticationError,  # Unauthorized - Invalid or missing authentication
                    '403': PermissionDenied,  # Forbidden - Insufficient permissions
                    '404': ExchangeError,  # Not Found - Resource not found
                    '429': RateLimitExceeded,  # Too Many Requests - Rate limit exceeded
                    '500': ExchangeError,  # Internal Server Error
                    '502': ExchangeError,  # Bad Gateway
                    '503': OnMaintenance,  # Service Unavailable - Service temporarily unavailable
                    '504': NetworkError,  # Gateway Timeout
                    # Common error messages(will be matched against error/message fields in response)
                    'Invalid signature': AuthenticationError,  # Invalid signature in request
                    'Invalid API key': AuthenticationError,  # Invalid or missing API key
                    'Invalid timestamp': AuthenticationError,  # Invalid timestamp in request
                    'Signature expired': AuthenticationError,  # Request timestamp is too old
                    'Unauthorized': AuthenticationError,  # Authentication failed
                    'Forbidden': PermissionDenied,  # Access denied
                    'Rate limit exceeded': RateLimitExceeded,  # Rate limit exceeded
                    'Too many requests': RateLimitExceeded,  # Too many requests
                    'Invalid order': InvalidOrder,  # Order validation failed
                    'Invalid orderID': OrderNotFound,  # Order does not exist
                    'Order not found': OrderNotFound,  # Order does not exist
                    'Insufficient funds': InsufficientFunds,  # Insufficient balance
                    'Insufficient balance': InsufficientFunds,  # Insufficient balance
                    'Invalid market': BadRequest,  # Invalid market/symbol
                    'Invalid symbol': BadRequest,  # Invalid symbol
                    'Market not found': BadRequest,  # Market does not exist
                    'Service unavailable': ExchangeNotAvailable,  # Service temporarily unavailable
                    'Maintenance': OnMaintenance,  # Service under maintenance
                },
                'broad': {
                    'authentication': AuthenticationError,  # Any authentication-related error
                    'authorization': PermissionDenied,  # Any authorization-related error
                    'rate limit': RateLimitExceeded,  # Any rate limit error
                    'invalid order': InvalidOrder,  # Any order validation error
                    'insufficient': InsufficientFunds,  # Any insufficient funds/balance error
                    'not found': ExchangeError,  # Any not found error
                    'timeout': NetworkError,  # Any timeout error
                    'network': NetworkError,  # Any network-related error
                    'maintenance': OnMaintenance,  # Any maintenance-related error
                },
            },
        })

    def get_signature_type(self, params={}):
        """
 Helper method to get signature type from params or options with fallback to constants
        :param dict [params]: parameters that may contain signatureType or signature_type
        :returns number|None: signature type value
        """
        signatureTypes = self.safe_dict(self.options, 'signatureTypes', {})
        eoaSignatureType = self.safe_integer(signatureTypes, 'EOA')
        polyProxySignatureType = self.safe_integer(signatureTypes, 'POLY_PROXY')
        polyGnosisSafeSignatureType = self.safe_integer(signatureTypes, 'POLY_GNOSIS_SAFE')
        # Note: POLY_GNOSIS_SAFE is not supported for now
        proxyWalletAddress = self.get_proxy_wallet_address()
        mainWalletAddress = self.get_main_wallet_address()
        if proxyWalletAddress != mainWalletAddress:
            return polyProxySignatureType
        return eoaSignatureType

    def get_side(self, sideString: str, params={}):
        """
 Helper method to get side from params or options with fallback to constants
 Converts BUY/SELL string to integer: BUY = 0, SELL = 1(matches UtilsBuy/UtilsSell from py-order-utils)
        :param str sideString: side('BUY' or 'SELL')
        :param dict [params]: parameters that may contain side or side_int
        :returns number: side(0 for BUY, 1 for SELL)
        """
        # Check if side_int is provided directly in params
        sideInt = self.safe_integer(params, 'sideInt') or self.safe_integer(params, 'side_int')
        if sideInt is not None:
            return sideInt
        # Get sides enum from options
        sides = self.safe_dict(self.options, 'sides', {})
        buySide = self.safe_integer(sides, 'BUY', 0)
        sellSide = self.safe_integer(sides, 'SELL', 1)
        # Convert side string to integer
        sideUpper = sideString.upper()
        sideValue = sellSide  # Default to SELL
        if sideUpper == 'BUY':
            sideValue = buySide
        return sideValue

    async def fetch_markets(self, params={}) -> List[Market]:
        """
        retrieves data on all markets for polymarket

        https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide#3-fetch-all-active-markets

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.active]: fetch active markets only(default: True)
        :param boolean [params.closed]: fetch closed markets
        :returns dict[]: an array of objects representing market data
        """
        limit = 500
        options = self.safe_dict(self.options, 'fetchMarkets', {})
        request: dict = self.extend({
            'order': 'id',
            'ascending': False,
            'limit': limit,
            'offset': 0,
        }, params)
        active = self.safe_bool(options, 'active', True)
        if self.safe_value(params, 'closed') is None:
            request['closed'] = not active
        offset = self.safe_integer(request, 'offset', 0)
        markets: List[Any] = []
        while(True):
            pageRequest = self.extend(request, {'offset': offset})
            response = await self.gamma_public_get_markets(pageRequest)
            page = self.safe_list(response, 'data', response) or []
            markets = self.array_concat(markets, page)
            if len(page) < limit:
                break
            offset += limit
        filtered = []
        for i in range(0, len(markets)):
            market = markets[i]
            id = self.safe_string(market, 'id')
            conditionId = self.safe_string(market, 'conditionId') or self.safe_string(market, 'condition_id')
            if id is None and conditionId is None:
                continue
            filtered.append(market)
        return self.parse_markets(filtered)

    def parse_market(self, market: dict) -> Market:
        # Schema uses 'conditionId'(camelCase)
        conditionId = self.safe_string(market, 'conditionId')
        question = self.safe_string(market, 'question')
        # Schema uses 'questionID'(camelCase)
        questionId = self.safe_string(market, 'questionID')
        # Schema uses 'slug'(camelCase)
        slug = self.safe_string(market, 'slug')
        active = self.safe_bool(market, 'active', False)
        closed = self.safe_bool(market, 'closed', False)
        archived = self.safe_bool(market, 'archived', False)
        outcomes = []
        outcomePrices = []
        outcomesStr = self.safe_string(market, 'outcomes')
        if outcomesStr is not None:
            parsedOutcomes = None
            try:
                parsedOutcomes = json.loads(outcomesStr)
            except Exception as e:
                parsedOutcomes = None
            if parsedOutcomes is not None and len(parsedOutcomes) is not None:
                for i in range(0, len(parsedOutcomes)):
                    outcomes.append(parsedOutcomes[i])
            else:
                outcomesArray = outcomesStr.split(',')
                for i in range(0, len(outcomesArray)):
                    v = outcomesArray[i].strip()
                    if v != '':
                        outcomes.append(v)
        outcomePricesStr = self.safe_string(market, 'outcomePrices')
        if outcomePricesStr is not None:
            parsedPrices = None
            try:
                parsedPrices = json.loads(outcomePricesStr)
            except Exception as e:
                parsedPrices = None
            if parsedPrices is not None and len(parsedPrices) is not None:
                for i in range(0, len(parsedPrices)):
                    outcomePrices.append(self.parse_number(parsedPrices[i]))
            else:
                pricesArray = outcomePricesStr.split(',')
                for i in range(0, len(pricesArray)):
                    v = pricesArray[i].strip()
                    if v != '':
                        outcomePrices.append(self.parse_number(v))
        # Use slug symbol if available
        baseId = slug or conditionId
        quoteId = self.safe_string(self.options, 'defaultCollateral', 'USDC')  # Polymarket uses USDC currency
        # Market type - Polymarket is a prediction market platform
        marketType: MarketType = 'option'  # Using 'option' match for prediction markets
        ammType = self.safe_string(market, 'ammType')
        # Schema uses 'enableOrderBook'(camelCase)
        enableOrderBook = self.safe_bool(market, 'enableOrderBook', False)
        # Market metadata
        category = self.safe_string(market, 'category')
        description = self.safe_string(market, 'description')
        tags = self.safe_value(market, 'tags', [])
        # Schema uses 'clobTokenIds'(camelCase) - can be string or array
        clobTokenIds = self.safe_value(market, 'clobTokenIds')
        if clobTokenIds is None:
            clobTokenIds = []
        if isinstance(clobTokenIds, str):
            parsed = None
            try:
                parsed = json.loads(clobTokenIds)
            except Exception as e:
                parsed = None
            if parsed is not None and parsed != None and len(parsed) is not None:
                clobTokenIds = []
                for i in range(0, len(parsed)):
                    clobTokenIds.append(parsed[i])
            else:
                cleaned = clobTokenIds
                cleaned = cleaned.replace('[', '').replace(']', '').replace('"', '')
                clobTokenIdsArray = cleaned.split(',')
                clobTokenIds = []
                for i in range(0, len(clobTokenIdsArray)):
                    v = clobTokenIdsArray[i].strip()
                    if v != '':
                        clobTokenIds.append(v)
        outcomesInfo = []
        length = len(outcomes)
        if len(outcomePrices) > length:
            length = len(outcomePrices)
        if len(clobTokenIds) > length:
            length = len(clobTokenIds)
        for i in range(0, length):
            outcome = None
            if i < len(outcomes):
                outcome = outcomes[i]
            price = None
            if i < len(outcomePrices):
                price = self.parse_number(outcomePrices[i])
            clobId = None
            if i < len(clobTokenIds):
                clobId = clobTokenIds[i]
            outcomeId = str(i)
            if clobId is not None:
                outcomeId = clobId
            outcomesInfo.append({
                'id': outcomeId,
                'name': outcome,
                'price': price,
                'clobId': clobId,
                'assetId': clobId,
            })
        # Parse dates - Schema uses 'endDateIso'(preferred) or 'endDate'(fallback)
        endDateIso = self.safe_string(market, 'endDateIso') or self.safe_string(market, 'endDate')
        # Schema uses 'createdAt'(camelCase)
        createdAt = self.safe_string(market, 'createdAt')
        createdTimestamp = None
        if createdAt is not None:
            createdTimestamp = self.parse8601(createdAt)
        # Volume and liquidity
        volume = self.safe_string(market, 'volume')
        volumeNum = self.safe_number(market, 'volumeNum')
        liquidity = self.safe_string(market, 'liquidity')
        liquidityNum = self.safe_number(market, 'liquidityNum')
        feesEnabled = self.safe_bool(market, 'feesEnabled', False)
        makerBaseFee = self.safe_number(market, 'makerBaseFee')
        takerBaseFee = self.safe_number(market, 'takerBaseFee')
        base = baseId
        quote = quoteId
        settle = quote  # Use quote
        # Parse expiry for option symbol formatting
        # Handle date-only strings(YYYY-MM-DD) by converting to ISO8601 datetime
        expiry = None
        expiryDatetime = endDateIso
        if endDateIso is not None:
            dateString = endDateIso
            # Check if it's a date-only string(YYYY-MM-DD format)
            if dateString.find(':') < 0:
                # Append time to make it a valid ISO8601 datetime
                dateString = dateString + 'T00:00:00Z'
            expiry = self.parse8601(dateString)
        # Format symbol with expiry date(similar to binance/okx option format)
        # Format: base/quote:settle-YYMMDD
        symbol = base + '/' + quote
        if expiry is not None:
            ymd = self.yymmdd(expiry)
            symbol = symbol + ':' + settle + '-' + ymd
        # Prediction markets don't have strike prices or option types in the schema
        # These fields are kept
        strike = None
        optionType = None
        contractSize = self.parse_number('1')
        # Calculate fees based on feesEnabled flag
        takerFee = self.parse_number('0')
        makerFee = self.parse_number('0')
        if feesEnabled:
            # Fees are enabled - use makerBaseFee and takerBaseFee from schema
            # These are typically in basis points(e.g., 200 = 2% = 0.02)
            if takerBaseFee is not None:
                takerFee = takerBaseFee / 10000  # Convert basis points to decimal
            if makerBaseFee is not None:
                makerFee = makerBaseFee / 10000  # Convert basis points to decimal
        created = self.milliseconds()  # TODO change it
        if createdTimestamp is not None:
            created = createdTimestamp
        volumeValue = self.parse_number('0')
        if volumeNum is not None:
            volumeValue = volumeNum
        elif volume is not None:
            volumeValue = self.parse_number(volume)
        liquidityValue = self.parse_number('0')
        if liquidityNum is not None:
            liquidityValue = liquidityNum
        elif liquidity is not None:
            liquidityValue = self.parse_number(liquidity)
        return {
            'id': conditionId,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'settle': settle,
            'baseId': baseId,
            'quoteId': quoteId,
            'settleId': settle,
            'type': marketType,
            'spot': False,
            'margin': False,
            'swap': False,
            'future': False,
            'option': True,  # Prediction markets are treated
            'active': enableOrderBook and active and not closed and not archived,
            'contract': True,
            'linear': None,
            'inverse': None,
            'contractSize': contractSize,
            'expiry': expiry,
            'expiryDatetime': expiryDatetime,
            'strike': strike,
            'optionType': optionType,
            'taker': takerFee,
            'maker': makerFee,
            'precision': {
                'amount': 6,  # https://github.com/Polymarket/clob-client/blob/main/src/config.ts
                'price': 6,  # https://github.com/Polymarket/clob-client/blob/main/src/config.ts
            },
            'limits': {
                'leverage': {
                    'min': None,
                    'max': None,
                },
                'amount': {
                    'min': None,
                    'max': None,
                },
                'price': {
                    'min': 0,  # Prediction markets are 0-1
                    'max': 1,  # Prediction markets are 0-1
                },
                'cost': {
                    'min': None,
                    'max': None,
                },
            },
            'created': created,
            'info': self.deep_extend(market, {
                'outcomes': outcomes,
                'outcomePrices': outcomePrices,
                'outcomesInfo': outcomesInfo,
                'question': question,
                'slug': slug,
                'category': category,
                'description': description,
                'tags': tags,
                'condition_id': conditionId,
                'question_id': questionId,
                'asset_id': questionId,
                'ammType': ammType,
                'enableOrderBook': enableOrderBook,
                'volume': volumeValue,
                'liquidity': liquidityValue,
                'endDateIso': endDateIso,
                'createdAt': createdAt,
                'createdTimestamp': createdTimestamp,
                'clobTokenIds': clobTokenIds,
                'quoteDecimals': 6,  # https://github.com/Polymarket/clob-client/blob/main/src/config.ts
                'baseDecimals': 6,  # https://github.com/Polymarket/clob-client/blob/main/src/config.ts
            }),
        }

    async def fetch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        """
        fetches the order book for a market

        https://docs.polymarket.com/api-reference/orderbook/get-order-book-summary

        :param str symbol: unified symbol of the market to fetch the order book for
        :param int [limit]: the maximum amount of order book entries to return
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID for the specific outcome(required if market has multiple outcomes)
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
        """
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {}
        # Get token ID from params or market info
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            marketInfo = self.safe_dict(market, 'info', {})
            clobTokenIds = self.safe_value(marketInfo, 'clobTokenIds', [])
            if len(clobTokenIds) > 0:
                # Use first token ID if multiple outcomes exist
                tokenId = clobTokenIds[0]
            else:
                raise ArgumentsRequired(self.id + ' fetchOrderBook() requires a token_id parameter for market ' + symbol)
        request['token_id'] = tokenId
        response = await self.clob_public_get_orderbook_token_id(self.extend(request, params))
        return self.parse_order_book(response, symbol)

    async def fetch_order_books(self, symbols: Strings = None, limit: Int = None, params={}) -> OrderBooks:
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data for multiple markets

        https://docs.polymarket.com/developers/CLOB/clients/methods-public#getorderbooks

        :param str[]|None symbols: list of unified market symbols, all symbols fetched if None, default is None
        :param int [limit]: the maximum amount of order book entries to return
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbol
        """
        await self.load_markets()
        if symbols is None:
            symbols = self.symbols
        # Build list of token IDs to fetch order books for
        tokenIds: List[str] = []
        tokenIdToSymbol: dict = {}
        for i in range(0, len(symbols)):
            symbol = symbols[i]
            market = self.market(symbol)
            marketInfo = self.safe_dict(market, 'info', {})
            clobTokenIds = self.safe_value(marketInfo, 'clobTokenIds', [])
            if len(clobTokenIds) > 0:
                # Use first token ID if multiple outcomes exist
                tokenId = clobTokenIds[0]
                tokenIds.append(tokenId)
                tokenIdToSymbol[tokenId] = symbol
        if len(tokenIds) == 0:
            return {}
        # Fetch order books for all token IDs at once using POST /books endpoint
        # See https://docs.polymarket.com/api-reference/orderbook/get-multiple-order-books-summaries-by-request
        # Request body: [{token_id: "..."}, {token_id: "..."}, ...]
        # Response format: array of order book objects, each with asset_id matching token_id
        requestBody = []
        for i in range(0, len(tokenIds)):
            requestItem: dict = {'token_id': tokenIds[i]}
            if limit is not None:
                requestItem['limit'] = limit
            requestBody.append(requestItem)
        response = await self.clob_public_post_books(self.extend({'requests': requestBody}, params))
        # Parse response: array of order book objects, each with asset_id field
        # Response is directly an array: [{asset_id: "...", bids: [...], asks: [...]}, ...]
        result: dict = {}
        if isinstance(response, list):
            for i in range(0, len(response)):
                orderbookData = response[i]
                assetId = self.safe_string(orderbookData, 'asset_id')
                symbol = tokenIdToSymbol[assetId]
                if symbol is not None:
                    try:
                        orderbook = self.parse_order_book(orderbookData, symbol)
                        result[symbol] = orderbook
                    except Exception as e:
                        # Skip markets that fail to parse
                        continue
        return result

    def parse_order_book(self, orderbook: dict, symbol: Str = None, timestamp: Int = None, bidsKey: Str = 'bids', asksKey: Str = 'asks', priceKey: Int = 0, amountKey: Int = 1, countOrIdKey: Int = 2) -> OrderBook:
        # Polymarket CLOB orderbook format(from /book endpoint)
        # See https://docs.polymarket.com/developers/CLOB/clients/methods-public#getorderbook
        # {
        #   "market": "string",
        #   "asset_id": "string",
        #   "timestamp": "string",
        #   "bids": [
        #     {
        #       "price": "0.65",  # string
        #       "size": "100"     # string
        #     }
        #   ],
        #   "asks": [
        #     {
        #       "price": "0.66",  # string
        #       "size": "50"      # string
        #     }
        #   ],
        #   "min_order_size": "string",
        #   "tick_size": "string",
        #   "neg_risk": boolean,
        #   "hash": "string"
        # }
        # Note: Ensure bids and asks are always arrays to avoid Python transpilation issues
        # safeList can return None, which becomes None in Python, causing len() to fail
        bids = self.safe_list(orderbook, 'bids', []) or []
        asks = self.safe_list(orderbook, 'asks', []) or []
        # Note: Using 'const' without explicit type annotation to avoid Python transpilation issues
        # The transpiler incorrectly preserves TypeScript tuple type annotations(e.g., ': [number, number][]') in Python code
        parsedBids = []
        parsedAsks = []
        for i in range(0, len(bids)):
            bid = bids[i]
            price = self.safe_number(bid, 'priceNumber', self.safe_number(bid, 'price'))
            amount = self.safe_number(bid, 'sizeNumber', self.safe_number(bid, 'size'))
            if price is not None and amount is not None:
                parsedBids.append([price, amount])
        for i in range(0, len(asks)):
            ask = asks[i]
            price = self.safe_number(ask, 'priceNumber', self.safe_number(ask, 'price'))
            amount = self.safe_number(ask, 'sizeNumber', self.safe_number(ask, 'size'))
            if price is not None and amount is not None:
                parsedAsks.append([price, amount])
        # Extract timestamp from orderbook response if available
        orderbookTimestamp = self.safe_string(orderbook, 'timestamp')
        finalTimestamp = timestamp
        if orderbookTimestamp is not None:
            # CLOB API returns timestamp string, convert to milliseconds
            finalTimestamp = self.parse8601(orderbookTimestamp)
        # Extract tick_size and neg_risk from orderbook if available(useful metadata)
        # These are also available via get_tick_size() and get_neg_risk() endpoints
        # Based on py-clob-client: get_tick_size() and get_neg_risk()
        tickSize = self.safe_string(orderbook, 'tick_size')
        negRisk = self.safe_bool(orderbook, 'neg_risk')
        minOrderSize = self.safe_string(orderbook, 'min_order_size')
        result: OrderBook = {
            'symbol': symbol,
            'bids': parsedBids,
            'asks': parsedAsks,
            'timestamp': finalTimestamp,
            'datetime': self.iso8601(finalTimestamp),
            'nonce': None,
        }
        # Include tick_size, neg_risk, and min_order_size in info if available(useful metadata)
        if tickSize is not None or negRisk is not None or minOrderSize is not None:
            metadata: dict = {}
            if tickSize is not None:
                metadata['tick_size'] = tickSize
            if negRisk is not None:
                metadata['neg_risk'] = negRisk
            if minOrderSize is not None:
                metadata['min_order_size'] = minOrderSize
            result['info'] = self.extend(orderbook, metadata)
        return result

    async def fetch_ticker(self, symbol: str, params={}) -> Ticker:
        """
        fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market

        https://docs.polymarket.com/api-reference/pricing/get-market-price
        https://docs.polymarket.com/api-reference/pricing/get-midpoint-price

        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID for the specific outcome(required if market has multiple outcomes)
        :param str [params.side]: the side: 'BUY' or 'SELL'(default: 'BUY')
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`

 **Currently Populated Fields:**
 - `bid` - Best bid price from POST /prices endpoint(BUY side)
 - `ask` - Best ask price from POST /prices endpoint(SELL side)
 - `last` - Midpoint price from GET /midpoint or lastTradePrice from market info
 - `open` - Calculated approximation: last / (1 + oneDayPriceChange)
 - `change` - Calculated: last - open
 - `percentage` - From oneDayPriceChange * 100(from market info)
 - `volume` - From volumeNum or volume(from market info)
 - `timestamp` - From updatedAt(parsed from ISO string)
 - `datetime` - ISO8601 formatted timestamp

 **Currently Undefined Fields(Available via Additional API Calls):**
 - `high` - Can be fetched from GET /prices-history(24h price history) or GET /trades(24h trades)
 - `low` - Can be fetched from GET /prices-history(24h price history) or GET /trades(24h trades)
 - `bidVolume` - Can be calculated from GET /book(order book) by summing all bid sizes
 - `askVolume` - Can be calculated from GET /book(order book) by summing all ask sizes
 - `vwap` - Can be calculated from GET /trades(24h trades) using volume-weighted average
 - `average` - Not available
 - `indexPrice` - Not available
 - `markPrice` - Not available

 **Enhancement Options:**

 1. **For High/Low/More Accurate Open:**
    - Use fetchOHLCV() to get 24h price history: `await exchange.fetchOHLCV(symbol, '1h', since24hAgo, None, {token_id: tokenId})`
    - Calculate high/low from OHLCV data
    - Use first candle's open price for accurate 24h open
    - API: GET /prices-history(see https://docs.polymarket.com/developers/CLOB/timeseries)

 2. **For VWAP:**
    - Use fetchTrades() to get 24h trades: `await exchange.fetchTrades(symbol, since24hAgo, None, {token_id: tokenId})`
    - Calculate: vwap = sum(trade.cost) / sum(trade.amount)
    - API: GET /trades(see https://docs.polymarket.com/api-reference/core/get-trades-for-a-user-or-markets)

 3. **For Bid/Ask Volumes:**
    - Use fetchOrderBook() to get order book: `await exchange.fetchOrderBook(symbol, None, {token_id: tokenId})`
    - Calculate: bidVolume = sum of all bid[1](sizes), askVolume = sum of all ask[1](sizes)
    - API: GET /book(see https://docs.polymarket.com/api-reference/orderbook/get-order-book-summary)

 4. **For More Accurate Last Price:**
    - Use GET /last-trade-price endpoint: `await exchange.clobPublicGetLastTradePrice({token_id: tokenId})`
    - API: GET /last-trade-price(see https://docs.polymarket.com/api-reference/trades/get-last-trade-price)
        """
        await self.load_markets()
        market = self.market(symbol)
        marketInfo = self.safe_dict(market, 'info', {})
        # Get token ID from params or market info
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            clobTokenIds = self.safe_value(marketInfo, 'clobTokenIds', [])
            if len(clobTokenIds) > 0:
                # Use first token ID if multiple outcomes exist
                tokenId = clobTokenIds[0]
            else:
                raise ArgumentsRequired(self.id + ' fetchTicker() requires a token_id parameter for market ' + symbol)
        # Fetch prices using POST /prices endpoint with both BUY and SELL sides
        # See https://docs.polymarket.com/api-reference/pricing/get-multiple-market-prices-by-request
        pricesResponse = await self.clob_public_post_prices(self.extend({
            'requests': [
                {'token_id': tokenId, 'side': 'BUY'},
                {'token_id': tokenId, 'side': 'SELL'},
            ],
        }, params))
        # Parse prices response: {[token_id]: {BUY: "price", SELL: "price"}, ...}
        tokenPrices = self.safe_dict(pricesResponse, tokenId, {})
        buyPrice = self.safe_string(tokenPrices, 'BUY')
        sellPrice = self.safe_string(tokenPrices, 'SELL')
        # Fetch midpoint if available(optional, ignore if not provided)
        midpoint = None
        try:
            midpointResponse = await self.clob_public_get_midpoint(self.extend({'token_id': tokenId}, params))
            midpoint = self.safe_string(midpointResponse, 'mid')
        except Exception as e:
            # Ignore midpoint if not available or fails
            midpoint = None
        # Combine pricing data with market info - already loaded from fetchMarkets
        combinedData = self.deep_extend(marketInfo, {
            'buyPrice': buyPrice,
            'sellPrice': sellPrice,
            'midpoint': midpoint,
        })
        return self.parse_ticker(combinedData, market)

    async def fetch_tickers(self, symbols: Strings = None, params={}) -> Tickers:
        """
        fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market

        https://docs.polymarket.com/api-reference/pricing/get-multiple-market-prices

        :param str[]|None symbols: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.fetchSpreads]: if True, also fetch bid-ask spreads for all markets(default: False)
        :returns dict: a dictionary of `ticker structures <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        await self.load_markets()
        # Build list of token IDs to fetch prices for
        tokenIds: List[str] = []
        tokenIdToSymbol: dict = {}
        symbolsToFetch = symbols or self.symbols
        for i in range(0, len(symbolsToFetch)):
            symbol = symbolsToFetch[i]
            market = self.market(symbol)
            marketInfo = self.safe_dict(market, 'info', {})
            clobTokenIds = self.safe_value(marketInfo, 'clobTokenIds', [])
            if len(clobTokenIds) > 0:
                # Use first token ID if multiple outcomes exist
                tokenId = clobTokenIds[0]
                tokenIds.append(tokenId)
                tokenIdToSymbol[tokenId] = symbol
        if len(tokenIds) == 0:
            return {}
        # Build requests array for POST /prices endpoint
        # Each token needs both BUY and SELL sides
        # See https://docs.polymarket.com/api-reference/pricing/get-multiple-market-prices-by-request
        requests = []
        for i in range(0, len(tokenIds)):
            tokenId = tokenIds[i]
            requests.append({'token_id': tokenId, 'side': 'BUY'})
            requests.append({'token_id': tokenId, 'side': 'SELL'})
        # Fetch prices for all token IDs at once using POST /prices endpoint
        # Response format: {[token_id]: {BUY: "price", SELL: "price"}, ...}
        # See https://docs.polymarket.com/api-reference/pricing/get-multiple-market-prices-by-request
        pricesResponse = await self.clob_public_post_prices(self.extend({'requests': requests}, params))
        # Optionally fetch spreads for all token IDs
        # See https://docs.polymarket.com/api-reference/spreads/get-bid-ask-spreads
        fetchSpreads = self.safe_bool(params, 'fetchSpreads', False)
        spreadsResponse = {}
        if fetchSpreads:
            try:
                spreadsResponse = await self.clob_public_post_spreads(self.extend({'token_ids': tokenIds}, params))
            except Exception as e:
                spreadsResponse = {}
        # Build market data map for efficient lookup
        tokenIdToMarket = {}
        for i in range(0, len(tokenIds)):
            tokenId = tokenIds[i]
            symbol = tokenIdToSymbol[tokenId]
            tokenIdToMarket[tokenId] = self.market(symbol)
        # Parse prices and build tickers(no additional fetching during parsing)
        tickers: dict = {}
        for i in range(0, len(tokenIds)):
            tokenId = tokenIds[i]
            symbol = tokenIdToSymbol[tokenId]
            market = tokenIdToMarket[tokenId]
            try:
                # Get prices from the response(both BUY and SELL are in the same response)
                tokenPrices = self.safe_dict(pricesResponse, tokenId, {})
                buyPrice = self.safe_string(tokenPrices, 'BUY')
                sellPrice = self.safe_string(tokenPrices, 'SELL')
                # Get spread if available
                spread = self.safe_string(spreadsResponse, tokenId)
                # Use market info data(already loaded from fetchMarkets)
                marketInfo = self.safe_dict(market, 'info', {})
                # Combine pricing data with market info
                combinedData = self.deep_extend(marketInfo, {
                    'buyPrice': buyPrice,
                    'sellPrice': sellPrice,
                    'spread': spread,
                })
                ticker = self.parse_ticker(combinedData, market)
                tickers[symbol] = ticker
            except Exception as e:
                # Skip markets that fail to parse
                continue
        return tickers

    def parse_ticker(self, ticker: dict, market: Market = None) -> Ticker:
        """
        parses a ticker data structure from Polymarket API response
        :param dict ticker: ticker data structure from Polymarket API
        :param dict [market]: market structure
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`

 **Data Sources:**
 - Market info from fetchMarkets()(volume, oneDayPriceChange, lastTradePrice, etc.)
 - Pricing API(buyPrice, sellPrice, midpoint)
 - Market metadata(updatedAt, volume24hr, volume1wk, volume1mo, volume1yr)

 **Currently Parsed Fields:**
 - `bid` - From buyPrice(POST /prices BUY side) or bestBid(market info)
 - `ask` - From sellPrice(POST /prices SELL side) or bestAsk(market info)
 - `last` - From midpoint(GET /midpoint) or lastTradePrice(market info)
 - `open` - Calculated: last / (1 + oneDayPriceChange) when both available
 - `change` - Calculated: last - open
 - `percentage` - From oneDayPriceChange * 100
 - `volume` - From volumeNum or volume(market info)
 - `timestamp` - From updatedAt(ISO string parsed to milliseconds)
 - `datetime` - ISO8601 formatted timestamp

 **Fields Set to Undefined(Can Be Enhanced):**
 - `high` - Not available in current data sources. Can be calculated from:
   - Price history: Math.max(...ohlcvData.map(c => c[2])) where c[2] is high
   - Trades: Math.max(...trades.map(t => t.price))
 - `low` - Not available in current data sources. Can be calculated from:
   - Price history: Math.min(...ohlcvData.map(c => c[3])) where c[3] is low
   - Trades: Math.min(...trades.map(t => t.price))
 - `bidVolume` - Not available. Can be calculated from order book:
   - orderbook.bids.reduce((sum, bid) => sum + bid[1], 0)
 - `askVolume` - Not available. Can be calculated from order book:
   - orderbook.asks.reduce((sum, ask) => sum + ask[1], 0)
 - `vwap` - Not available. Can be calculated from trades:
   - totalCost = trades.reduce((sum, t) => sum + t.cost, 0)
   - totalVolume = trades.reduce((sum, t) => sum + t.amount, 0)
   - vwap = totalCost / totalVolume

 **To Enhance Ticker Data:**
 Before calling parseTicker(), you can fetch additional data and add it to the ticker dict:

 ```typescript
  # Example: Add high/low from price history
 since24h = exchange.milliseconds() - 24 * 60 * 60 * 1000
 ohlcv = await exchange.fetchOHLCV(symbol, '1h', since24h, None, {token_id: tokenId})
 if len(ohlcv) > 0:
     highs = ohlcv.map(c => c[2])  # OHLCV[2] is high
     lows = ohlcv.map(c => c[3])  # OHLCV[3] is low
     ticker['high'] = Math.max(...highs)
     ticker['low'] = Math.min(...lows)
     ticker['open'] = ohlcv[0][1]  # First candle's open
}

  # Example: Add VWAP from trades
 trades = await exchange.fetchTrades(symbol, since24h, None, {token_id: tokenId})
 if len(trades) > 0:
     totalCost = 0
     totalVolume = 0
     for i in range(0, len(trades)):
         totalCost += trades[i]['cost']
         totalVolume += trades[i]['amount']
     }
     ticker['vwap'] = totalVolume > totalCost / totalVolume if 0 else None
}

  # Example: Add bid/ask volumes from order book
 orderbook = await exchange.fetchOrderBook(symbol, None, {token_id: tokenId})
 bidVolume = 0
 askVolume = 0
 for i in range(0, len(orderbook['bids'])):
     bidVolume += orderbook['bids'][i][1]
}
 for i in range(0, len(orderbook['asks'])):
     askVolume += orderbook['asks'][i][1]
}
 ticker['bidVolume'] = bidVolume
 ticker['askVolume'] = askVolume
 ```
        """
        # Polymarket ticker format from market data
        symbol = market['symbol'] if market else None
        # Parse outcome prices
        outcomePricesStr = self.safe_string(ticker, 'outcomePrices')
        outcomePrices = []
        if outcomePricesStr:
            try:
                parsed = json.loads(outcomePricesStr)
                # Note: Ensure all elements are numbers - json.loadsmay return strings
                # Convert each element to a number to avoid Python multiplication errors
                if parsed is not None and parsed != None and len(parsed) is not None:
                    for i in range(0, len(parsed)):
                        price = self.parse_number(parsed[i])
                        if price is not None:
                            outcomePrices.append(price)
            except Exception as e:
                # Note: Using for loop instead of .map() to avoid Python transpilation issues
                # Arrow functions with type annotations(e.g., '(p: string) =>') are incorrectly preserved in Python
                pricesArray = outcomePricesStr.split(',')
                for i in range(0, len(pricesArray)):
                    price = self.parse_number(pricesArray[i].strip())
                    if price is not None:
                        outcomePrices.append(price)
        last = None
        bid = None
        ask = None
        high = None
        low = None
        # Volume data
        volume = self.safe_number(ticker, 'volumeNum', self.safe_number(ticker, 'volume'))
        volume24hr = self.safe_number(ticker, 'volume24hr')
        volume1wk = self.safe_number(ticker, 'volume1wk')
        volume1mo = self.safe_number(ticker, 'volume1mo')
        volume1yr = self.safe_number(ticker, 'volume1yr')
        # Price changes
        oneDayPriceChange = self.safe_number(ticker, 'oneDayPriceChange')
        # Best bid/ask from pricing API(BUY = bid, SELL = ask)
        buyPrice = self.safe_number(ticker, 'buyPrice')
        sellPrice = self.safe_number(ticker, 'sellPrice')
        midpoint = self.safe_number(ticker, 'midpoint')
        # Use pricing API data if available
        if buyPrice is not None:
            bid = buyPrice
        if sellPrice is not None:
            ask = sellPrice
        if midpoint is not None:
            last = midpoint
        # Fallback to ticker data if pricing API data not available
        bestBid = self.safe_number(ticker, 'bestBid')
        bestAsk = self.safe_number(ticker, 'bestAsk')
        lastTradePrice = self.safe_number(ticker, 'lastTradePrice')
        if bid is None and bestBid is not None:
            bid = bestBid
        if ask is None and bestAsk is not None:
            ask = bestAsk
        if last is None and lastTradePrice is not None:
            last = lastTradePrice
        # Timestamp
        updatedAtString = self.safe_string(ticker, 'updatedAt')
        timestamp = self.parse8601(updatedAtString) if updatedAtString else None
        datetime = self.iso8601(timestamp) if timestamp else None
        # Open(previous closing price - approximated)
        open = last is not None and oneDayPriceChange is not last / (1 + oneDayPriceChange) if None else None
        # Change and percentage
        change = last is not None and open is not last - open if None else None
        percentage = oneDayPriceChange is not oneDayPriceChange * 100 if None else None
        # Add additional Polymarket-specific fields to info
        tickerInfo = self.safe_dict(ticker, 'info', {})
        extendedInfo = self.deep_extend(tickerInfo, {
            'buyPrice': buyPrice,
            'sellPrice': sellPrice,
            'midpoint': midpoint,
            'lastTradePrice': lastTradePrice,
            'volume24hr': volume24hr,
            'volume1wk': volume1wk,
            'volume1mo': volume1mo,
            'volume1yr': volume1yr,
        })
        return {
            'symbol': symbol,
            'info': self.deep_extend(ticker, {'info': extendedInfo}),
            'timestamp': timestamp,
            'datetime': datetime,
            'high': high,
            'low': low,
            'bid': bid,
            'bidVolume': None,
            'ask': ask,
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': open,
            'change': change,
            'percentage': percentage,
            'average': None,
            'baseVolume': volume,
            'quoteVolume': volume,
            'indexPrice': None,
            'markPrice': None,
        }

    async def fetch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        get the list of most recent trades for a particular symbol

        https://docs.polymarket.com/api-reference/core/get-trades-for-a-user-or-markets

        :param str symbol: unified symbol of the market to fetch trades for
        :param int [since]: timestamp in ms of the earliest trade to fetch
        :param int [limit]: the maximum amount of trades to fetch(default: 100, max: 10000)
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.offset]: offset for pagination(default: 0, max: 10000)
        :param boolean [params.takerOnly]: if True, returns only trades where the user is the taker(default: True)
        :param str [params.side]: filter by side: 'BUY' or 'SELL'
        :returns Trade[]: a list of `trade structures <https://docs.ccxt.com/#/?id=public-trades>`
        """
        await self.load_markets()
        market = self.market(symbol)
        marketInfo = self.safe_dict(market, 'info', {})
        # Get condition_id from market info(self is the market ID for Polymarket)
        conditionId = self.safe_string(marketInfo, 'condition_id', market['id'])
        request: dict = {
            'market': [conditionId],  # Data API expects an array of condition IDs
        }
        # Note: Data API /trades endpoint supports limit(default: 100, max: 10000) and offset for pagination
        # The 'since' parameter is not directly supported by the REST API
        if limit is not None:
            request['limit'] = min(limit, 10000)  # Cap at max 10000
        offset = self.safe_integer(params, 'offset')
        if offset is not None:
            request['offset'] = offset
        takerOnly = self.safe_bool(params, 'takerOnly', True)
        request['takerOnly'] = takerOnly
        side = self.safe_string_upper(params, 'side')
        if side is not None:
            request['side'] = side
        response = await self.data_public_get_trades(self.extend(request, self.omit(params, ['offset', 'takerOnly', 'side'])))
        tradesData = []
        if isinstance(response, list):
            tradesData = response
        else:
            dataList = self.safe_list(response, 'data', [])
            if dataList is not None:
                tradesData = dataList
        return self.parse_trades(tradesData, market, since, limit)

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        # Detect Data API format(has conditionId field) vs CLOB format(has market/asset_id fields)
        # Check for both camelCase and snake_case for robustness
        conditionId = self.safe_string_2(trade, 'conditionId', 'condition_id')
        isDataApiFormat = conditionId is not None
        if isDataApiFormat:
            # Data API format: https://docs.polymarket.com/api-reference/core/get-trades-for-a-user-or-markets
            # {
            #   "proxyWallet": "0x...",
            #   "side": "BUY",
            #   "asset": "<string>",
            #   "conditionId": "0x...",
            #   "size": 123,
            #   "price": 123,
            #   "timestamp": 123,
            #   "transactionHash": "0x...",
            #   ...
            # }
            # Use transactionHash, check both camelCase and snake_case
            id = self.safe_string_2(trade, 'transactionHash', 'transaction_hash')
            symbol = None
            if market is not None and market['symbol'] is not None:
                symbol = market['symbol']
            elif conditionId is not None:
                resolved = self.safe_market(conditionId, None)
                resolvedSymbol = self.safe_string(resolved, 'symbol')
                if resolvedSymbol is not None:
                    symbol = resolvedSymbol
                else:
                    symbol = conditionId
            timestampSeconds = self.safe_integer(trade, 'timestamp')
            timestamp = None
            if timestampSeconds is not None:
                timestamp = timestampSeconds * 1000
            side = self.safe_string_lower(trade, 'side')
            price = self.safe_number(trade, 'price')
            amount = self.safe_number(trade, 'size')
            cost = None
            if price is not None and amount is not None:
                cost = price * amount
            # Data API doesn't provide fee information
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': self.iso8601(timestamp),
                'symbol': symbol,
                'type': None,
                'side': side,
                'takerOrMaker': None,  # Data API doesn't provide self information
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': None,  # Data API doesn't provide fee information
                'order': None,  # Data API doesn't provide order ID
            }
        else:
            # CLOB Trade format(backward compatibility)
            # interface Trade {
            #   id: string
            #   taker_order_id: string
            #   market: string
            #   asset_id: string
            #   side: Side
            #   size: string
            #   fee_rate_bps: string
            #   price: string
            #   status: string
            #   match_time: string
            #   last_update: string
            #   outcome: string
            #   bucket_index: number
            #   owner: string
            #   maker_address: string
            #   maker_orders: MakerOrder[]
            #   transaction_hash: string
            #   trader_side: "TAKER" | "MAKER"
            # }
            id = self.safe_string(trade, 'id')
            assetId = self.safe_string(trade, 'asset_id')
            tradeMarket = self.safe_string(trade, 'market')
            symbol = None
            if market is not None and market['symbol'] is not None:
                symbol = market['symbol']
            elif tradeMarket is not None:
                resolved = self.safe_market(tradeMarket, None)
                resolvedSymbol = self.safe_string(resolved, 'symbol')
                if resolvedSymbol is not None:
                    symbol = resolvedSymbol
                else:
                    symbol = tradeMarket
            elif assetId is not None:
                resolved = self.safe_market(assetId, market)
                resolvedSymbol = self.safe_string(resolved, 'symbol')
                if resolvedSymbol is not None:
                    symbol = resolvedSymbol
                else:
                    symbol = assetId
            matchTime = self.safe_integer(trade, 'match_time')
            timestamp = None
            if matchTime is not None:
                timestamp = matchTime * 1000
            # Top-level fields are from the taker perspective; for maker trades use maker_orders
            side = self.safe_string_lower(trade, 'side')
            price = self.safe_number(trade, 'price')
            amount = self.safe_number(trade, 'size')
            feeRateBps = self.safe_number(trade, 'fee_rate_bps')
            traderSide = self.safe_string_upper(trade, 'trader_side')
            if traderSide == 'MAKER':
                makerOrders = self.safe_value(trade, 'maker_orders', [])
                proxyWallet = self.get_proxy_wallet_address()
                userAddress = proxyWallet.lower()
                matched = False
                for i in range(0, len(makerOrders)):
                    m = makerOrders[i]
                    mAddr = self.safe_string(m, 'maker_address')
                    if mAddr is not None:
                        mAddrLower = mAddr.lower()
                        if mAddrLower == userAddress:
                                price = self.safe_number(m, 'price')
                                amount = self.safe_number(m, 'matched_amount')
                                side = self.safe_string_lower(m, 'side')
                                feeRateBps = self.safe_number(m, 'fee_rate_bps')
                                matched = True
                                break
                if not matched:
                    m = makerOrders[0]
                    price = self.safe_number(m, 'price')
                    amount = self.safe_number(m, 'matched_amount')
                    side = self.safe_string_lower(m, 'side')
                    feeRateBps = self.safe_number(m, 'fee_rate_bps')
            feeCost = None
            if feeRateBps is not None and price is not None and amount is not None:
                feeCost = price * amount * feeRateBps / 10000
            fee = None
            if feeCost is not None:
                fee = {
                    'cost': feeCost,
                    'currency': self.safe_string(self.options, 'defaultCollateral', 'USDC'),
                    'rate': feeRateBps is not feeRateBps / 10000 if None else None,
                }
            cost = price * amount if (price is not None and amount is not None) else None
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': self.iso8601(timestamp),
                'symbol': symbol,
                'type': None,
                'side': side,
                'takerOrMaker': self.safe_string_lower(trade, 'trader_side'),
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
                'order': self.safe_string(trade, 'taker_order_id'),
            }

    async def fetch_ohlcv(self, symbol: str, timeframe: str = '1h', since: Int = None, limit: Int = None, params={}) -> List[list]:
        """
        fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market

        https://docs.polymarket.com/developers/CLOB/clients/methods-public#getpriceshistory

        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int [since]: timestamp in ms of the earliest candle to fetch
        :param int [limit]: the maximum amount of candles to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID for the specific outcome(required if market has multiple outcomes)
        :param int [params.endTs]: timestamp in seconds for the ending date filter
        :param number [params.fidelity]: data fidelity/quality
        :returns int[][]: A list of candles ordered, open, high, low, close, volume
        """
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {}
        # Get token ID from params or market info
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            marketInfo = self.safe_dict(market, 'info', {})
            clobTokenIds = self.safe_value(marketInfo, 'clobTokenIds', [])
            if len(clobTokenIds) > 0:
                # Use first token ID if multiple outcomes exist
                tokenId = clobTokenIds[0]
            else:
                raise ArgumentsRequired(self.id + ' fetchOHLCV() requires a token_id parameter for market ' + symbol)
        request['market'] = tokenId  # API uses 'market' parameter for token_id
        # Note: REST API /prices-history endpoint requires either:
        # 1. startTs and endTs(mutually exclusive with interval)
        # 2. interval(mutually exclusive with startTs/endTs)
        # See https://docs.polymarket.com/developers/CLOB/timeseries
        # Supported intervals: "1m", "1h", "6h", "1d", "1w", "max"
        # CCXT will automatically reject unsupported timeframes based on the 'timeframes' definition
        endTs = self.safe_integer(params, 'endTs')
        if since is not None or endTs is not None:
            # Use startTs/endTs when time range is specified
            if since is not None:
                # Convert milliseconds to seconds for API
                request['startTs'] = self.parse_to_int(since / 1000)
            if endTs is not None:
                request['endTs'] = endTs
        else:
            # Use interval when no time range is specified
            # CCXT will validate the timeframe against the 'timeframes' definition
            # Map to API format(timeframe should already be validated by CCXT)
            request['interval'] = timeframe
        # Fidelity parameter controls data granularity(e.g., 720 for 12-hour intervals)
        # If not provided, API may use default fidelity
        fidelity = self.safe_number(params, 'fidelity')
        # Polymarket enforces minimum fidelity per interval(e.g. interval=1m requires fidelity>=10)
        # Avoid leaking a server-side validation error back to the user when a too-low value is supplied.
        if timeframe == '1m':
            if fidelity is None:
                fidelity = 10
            else:
                fidelity = min(10, fidelity)
        if fidelity is not None:
            request['fidelity'] = fidelity
        remainingParams = self.omit(params, ['token_id', 'endTs', 'fidelity'])
        response = await self.clob_public_get_prices_history(self.extend(request, remainingParams))
        ohlcvData = []
        if isinstance(response, list):
            ohlcvData = response
        else:
            # Response has 'history' key containing the array
            ohlcvData = self.safe_list(response, 'history', []) or []
        return self.parse_ohlcvs(ohlcvData, market, timeframe, since, limit)

    def parse_ohlcv(self, ohlcv: Any, market: Market = None) -> list:
        # Polymarket MarketPrice format from getPricesHistory
        # See https://docs.polymarket.com/developers/CLOB/clients/methods-public#getpriceshistory
        # {
        #   "t": number,  # timestamp in seconds
        #   "p": number   # price
        # }
        # Note: Polymarket only returns price data, not full OHLCV
        # We'll use the price, high, low, and close, with volume
        timestamp = self.safe_integer(ohlcv, 't')
        price = self.safe_number(ohlcv, 'p')
        # Convert timestamp from seconds to milliseconds
        if timestamp is not None:
            timestamp = timestamp * 1000
        return [
            timestamp,
            price,  # open
            price,  # high(same since we only have price)
            price,  # low(same since we only have price)
            price,  # close
            0,     # volume(not available in price history)
        ]

    def get_rounding_config(self, tickSize: str) -> dict:
        """
        Get rounding configuration based on tick size(matches ROUNDING_CONFIG from official SDK)
        :param str tickSize: tick size string(e.g., '0.1', '0.01', '0.001', '0.0001')
        :returns dict: rounding configuration with price, size, and amount decimal places
        """
        # Determine rounding config based on tick size(matches ROUNDING_CONFIG from SDK)
        # Returns: {price: number, size: number, amount: number}
        priceDecimals = 2
        sizeDecimals = 2
        amountDecimals = 4
        if tickSize == '0.1':
            priceDecimals = 1
            sizeDecimals = 2
            amountDecimals = 3
        elif tickSize == '0.01':
            priceDecimals = 2
            sizeDecimals = 2
            amountDecimals = 4
        elif tickSize == '0.001':
            priceDecimals = 3
            sizeDecimals = 2
            amountDecimals = 5
        elif tickSize == '0.0001':
            priceDecimals = 4
            sizeDecimals = 2
            amountDecimals = 6
        return {
            'price': priceDecimals,
            'size': sizeDecimals,
            'amount': amountDecimals,
        }

    def round_down(self, value: str, decimals: float) -> str:
        """
        Round down(truncate) a value to specific decimal places
        :param str value: value to round down
        :param number decimals: number of decimal places
        :returns str: rounded down value
        """
        return self.decimal_to_precision(value, 0, decimals, 2, 5)

    def round_normal(self, value: str, decimals: float) -> str:
        """
        Round a value normally to specific decimal places
        :param str value: value to round
        :param number decimals: number of decimal places
        :returns str: rounded value
        """
        return self.decimal_to_precision(value, 1, decimals, 2, 5)

    def round_up(self, value: str, decimals: float) -> str:
        """
        Round up a value to specific decimal places
        :param str value: value to round up
        :param number decimals: number of decimal places
        :returns str: rounded up value
        """
        return self.decimal_to_precision(value, 2, decimals, 2, 5)

    def decimal_places(self, value: str) -> float:
        """
        Count the number of decimal places in a string value
        :param str value: value to count decimal places for
        :returns number: number of decimal places
        """
        parts = value.split('.')
        if len(parts) == 2:
            return len(parts[1])
        return 0

    def to_token_decimals(self, value: str, decimals: float) -> str:
        """
        Convert a value to token decimals(smallest unit) by multiplying by 10^decimals and truncating
        :param str value: value to convert
        :param number decimals: number of decimals(e.g., 6 for USDC, 18 for tokens)
        :returns str: value in smallest unit
        """
        # Multiply by 10^decimals and truncate to integer
        multiplier = self.integer_precision_to_amount(self.number_to_string(-decimals))
        return Precise.string_div(Precise.string_mul(value, multiplier), '1', 0)

    async def build_and_sign_order(self, tokenId: str, side: str, size: str, price: str = None, market: Market = None, params={}) -> dict:
        """
        Builds and signs an order with EIP-712 according to Polymarket order-utils specification

        https://github.com/Polymarket/clob-order-utils
        https://github.com/Polymarket/clob-client/blob/main/src/order-builder/builder.ts
        https://github.com/Polymarket/python-order-utils/blob/main/py_order_utils/builders/order_builder.py

        :param str tokenId: the token ID
        :param str side: 'BUY' or 'SELL'
        :param str size: order size
        :param str [price]: order price(required for limit orders)
        :param dict [market]: market structure(optional, used to get fees)
        :param dict [params]: extra parameters
        :param number [params.expiration]: expiration timestamp in seconds(default: 30 days from now)
        :param number [params.nonce]: order nonce(default: 0)
        :param number [params.feeRateBps]: fee rate in basis points(default: from market or 200 bps)
        :param str [params.maker]: maker address(default: getMainWalletAddress())
        :param str [params.taker]: taker address(default: zero address)
        :param str [params.signer]: signer address(default: maker address)
        :param number [params.signatureType]: signature type(default: from options.signatureType or options.signatureTypes.EOA).
        :param str [params.orderType]: order type: 'GTC', 'IOC', 'FOK', 'GTD'(default: 'GTC' for limit orders, 'FOK' for market orders)
        :returns dict: signed order object ready for submission
        """
        # Get zero address constant(matches py-clob-client ZERO_ADDRESS)
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/constants.py
        zeroAddress = self.safe_string(self.options, 'zeroAddress', '0x0000000000000000000000000000000000000000')
        # Get signature type
        signatureType = self.get_signature_type(params)
        # Get maker address(wallet address) - checksummed for signing
        maker = self.safe_string(params, 'maker')
        if maker is None:
            signatureTypes = self.safe_dict(self.options, 'signatureTypes', {})
            eoaSignatureType = self.safe_integer(signatureTypes, 'EOA')
            if signatureType == eoaSignatureType:
                maker = self.get_main_wallet_address()
            else:
                maker = self.get_proxy_wallet_address()
        normalizedMaker = self.normalize_address(maker)
        # Get taker address(default: zero address for open orders)
        taker = self.safe_string(params, 'taker', zeroAddress)
        normalizedTaker = self.normalize_address(taker)
        # Get fee rate in basis points from market or params
        feeRateBps = self.safe_integer(params, 'feeRateBps')
        if feeRateBps is None:
            if market is not None:
                # Try to get fee from market structure
                marketInfo = self.safe_dict(market, 'info', {})
                # First try takerBaseFee from market info(in basis points)
                feeRateBps = self.safe_integer(marketInfo, 'takerBaseFee')
                if feeRateBps is None:
                    # Try taker fee from parsed market(decimal, convert to basis points)
                    takerFee = self.safe_number(market, 'taker')
                    if takerFee is not None:
                        feeRateBps = int(round(takerFee * 10000))
            # Fallback to default fee rate from options if not found in market
            if feeRateBps is None:
                feeRateBps = self.safe_integer(self.options, 'defaultFeeRateBps', 200)
        # Get expiration(default: from options.defaultExpirationDays, or 30 days from now in seconds)
        expiration = self.safe_integer(params, 'expiration')
        if expiration is None:
            nowSeconds = int(math.floor(self.milliseconds()) / 1000)
            defaultExpirationDays = self.safe_integer(self.options, 'defaultExpirationDays', 30)
            expiration = nowSeconds + (defaultExpirationDays * 24 * 60 * 60)
        # Get nonce(default: current timestamp in seconds)
        nonce = self.safe_integer(params, 'nonce')
        if nonce is None:
            nonce = 0  # Default nonce is 0
        # Get signer address(default: maker address)
        signer = self.safe_string(params, 'signer')
        if signer is None:
            signer = self.get_main_wallet_address()
        normalizedSigner = self.normalize_address(signer)
        # Generate salt(unique integer based on microseconds)
        # Using microseconds for better uniqueness without relying on Math.random()
        salt = int(math.floor(self.milliseconds()) / 1000)
        # Calculate makerAmount and takerAmount from size and price
        # Key steps: 1) Round down size first, 2) Calculate other amount, 3) Round if needed, 4) Convert to smallest units
        # Get precision from market info or use defaults(USDC: 6 decimals, Tokens: 18 decimals)
        orderMarketInfo: Any = {}
        if market is not None:
            orderMarketInfo = self.safe_dict(market, 'info', {})
        marketPrecision: Any = {}
        if market is not None:
            marketPrecision = self.safe_dict(market, 'precision', {})
        quoteDecimals = self.safe_integer(orderMarketInfo, 'quoteDecimals', self.safe_integer(marketPrecision, 'price'))
        baseDecimals = self.safe_integer(orderMarketInfo, 'baseDecimals', self.safe_integer(marketPrecision, 'amount'))
        defaultTickSize = self.safe_string(self.options, 'defaultTickSize')
        tickSize = self.safe_string(orderMarketInfo, 'tick_size', defaultTickSize)
        roundingConfig = self.get_rounding_config(tickSize)
        priceDecimals = self.safe_integer(roundingConfig, 'price', 2)
        sizeDecimals = self.safe_integer(roundingConfig, 'size', 2)
        amountDecimals = self.safe_integer(roundingConfig, 'amount', 4)
        makerAmount: str
        takerAmount: str
        isBuy = (side.upper() == 'BUY')
        # Get price: from parameter, or from params.marketPrice for market orders
        orderPrice = price
        if orderPrice is None:
            orderPrice = self.safe_string(params, 'marketPrice')
        if orderPrice is None:
            raise ArgumentsRequired(self.id + ' buildAndSignOrder() requires a price parameter or params.marketPrice')
        # Round price and size first, then calculate amounts(same logic for limit and market orders)
        rawPrice = self.round_normal(orderPrice, priceDecimals)
        # Check if self is a market order for special decimal handling
        orderType = self.safe_string(params, 'orderType', 'limit')
        isMarketOrder = (orderType == 'market')
        # Get rounding buffer constant
        roundingBuffer = self.safe_integer(self.options, 'roundingBufferDecimals', 4)
        # Determine decimal precision based on order type and side
        makerDecimals = 0
        takerDecimals = 0
        if isMarketOrder:
            # Get market order decimal limits for quote(USDC) and base(tokens)
            marketOrderQuoteDecimals = self.safe_integer(self.options, 'marketOrderQuoteDecimals', 2)
            marketOrderBaseDecimals = self.safe_integer(self.options, 'marketOrderBaseDecimals', 4)
            if isBuy:
                # Market buy orders: maker gives USDC(quote), taker gives tokens(base)
                makerDecimals = marketOrderQuoteDecimals
                takerDecimals = marketOrderBaseDecimals
            else:
                # Market sell orders: maker gives tokens(base), taker gives USDC(quote)
                makerDecimals = marketOrderBaseDecimals
                takerDecimals = marketOrderQuoteDecimals
        else:
            # Limit orders: use amountDecimals for both
            makerDecimals = amountDecimals
            takerDecimals = amountDecimals
        if isBuy:
            # BUY: maker gives USDC, wants tokens
            # Round down size first
            rawTakerAmt = self.round_down(size, sizeDecimals)
            # Round taker amount to max decimals
            if self.decimal_places(rawTakerAmt) > takerDecimals:
                rawTakerAmt = self.round_down(rawTakerAmt, takerDecimals)
            # Calculate maker amount: raw_maker_amt = raw_taker_amt * raw_price
            # Do NOT round calculated amounts - preserve full precision for accurate calculations
            # The decimal limits apply to input size and final representation, not intermediate calculations
            rawMakerAmt = Precise.string_mul(rawTakerAmt, rawPrice)
            # Convert to smallest units: maker gives USDC(quoteDecimals), taker gives tokens(baseDecimals)
            makerAmount = self.to_token_decimals(rawMakerAmt, quoteDecimals)
            takerAmount = self.to_token_decimals(rawTakerAmt, baseDecimals)
        else:
            # SELL: maker gives tokens, wants USDC
            # Round down size first
            rawMakerAmt = self.round_down(size, sizeDecimals)
            # Round maker amount to max decimals
            if self.decimal_places(rawMakerAmt) > makerDecimals:
                rawMakerAmt = self.round_down(rawMakerAmt, makerDecimals)
            # Calculate taker amount: raw_taker_amt = raw_maker_amt * raw_price
            # Do NOT round calculated amounts - preserve full precision for accurate calculations
            # The decimal limits apply to input size and final representation, not intermediate calculations
            rawTakerAmt = Precise.string_mul(rawMakerAmt, rawPrice)
            # Convert to smallest units: maker gives tokens(baseDecimals), taker gives USDC(quoteDecimals)
            makerAmount = self.to_token_decimals(rawMakerAmt, baseDecimals)
            takerAmount = self.to_token_decimals(rawTakerAmt, quoteDecimals)
        sideInt = self.get_side(side, params)
        order: dict = {
            'salt': str(salt),  # uint256
            'maker': normalizedMaker,  # address
            'signer': normalizedSigner,  # address
            'taker': normalizedTaker,  # address
            'tokenId': str(tokenId),  # uint256
            'makerAmount': str(makerAmount),  # uint256
            'takerAmount': str(takerAmount),  # uint256
            'expiration': str(expiration),  # uint256
            'nonce': str(nonce),  # uint256
            'feeRateBps': str(feeRateBps),  # uint256
            'side': sideInt,  # uint8: number(0 or 1)
            'signatureType': signatureType,  # uint8: number(0, 1, or 2)
        }
        chainId = self.safe_integer(self.options, 'chainId')
        orderDomainName = self.safe_string(self.options, 'orderDomainName')
        orderDomainVersion = self.safe_string(self.options, 'orderDomainVersion')
        contractConfig = self.get_contract_config(chainId)
        verifyingContract = self.normalize_address(self.safe_string(contractConfig, 'exchange'))
        # Domain must match exactly what server expects for signature validation
        domain = {
            'name': orderDomainName,
            'version': orderDomainVersion,
            'chainId': chainId,
            'verifyingContract': verifyingContract,
        }
        # EIP-712 types for orders from https://github.com/Polymarket/clob-order-utils/blob/main/src/exchange.order.const.ts
        ORDER_STRUCTURE = [
            {'name': 'salt', 'type': 'uint256'},
            {'name': 'maker', 'type': 'address'},
            {'name': 'signer', 'type': 'address'},
            {'name': 'taker', 'type': 'address'},
            {'name': 'tokenId', 'type': 'uint256'},
            {'name': 'makerAmount', 'type': 'uint256'},
            {'name': 'takerAmount', 'type': 'uint256'},
            {'name': 'expiration', 'type': 'uint256'},
            {'name': 'nonce', 'type': 'uint256'},
            {'name': 'feeRateBps', 'type': 'uint256'},
            {'name': 'side', 'type': 'uint8'},
            {'name': 'signatureType', 'type': 'uint8'},
        ]
        # primary type is types[0] => 'primaryType': 'Order'
        # EIP712Domain shouldn't be included in messageTypes
        messageTypes: dict = {
            'Order': ORDER_STRUCTURE,
        }
        signature = self.sign_typed_data(domain, messageTypes, order)
        order['signature'] = signature
        return order

    async def build_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}) -> dict:
        """
        build a signed order request payload from order parameters

        https://docs.polymarket.com/developers/CLOB/orders/create-order
        https://docs.polymarket.com/developers/CLOB/orders/create-order-batch

        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency
        :param float [price]: the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID(required if market has multiple outcomes)
        :param str [params.timeInForce]: 'GTC', 'IOC', 'FOK', 'GTD'(default: 'GTC')
        :param str [params.clientOrderId]: a unique id for the order
        :param boolean [params.postOnly]: if True, the order will only be posted to the order book and not executed immediately
        :param number [params.expiration]: expiration timestamp in seconds(default: 30 days from now)
        :returns dict: request payload with order, owner, orderType, and optional fields
        """
        market = self.market(symbol)
        marketInfo = self.safe_dict(market, 'info', {})
        # Get token ID from params or market info
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            clobTokenIds = self.safe_value(marketInfo, 'clobTokenIds', [])
            if len(clobTokenIds) > 0:
                # Use first token ID if multiple outcomes exist
                tokenId = clobTokenIds[0]
            else:
                raise ArgumentsRequired(self.id + ' buildOrder() requires a token_id parameter for market ' + symbol)
        # Convert CCXT side to Polymarket side(BUY/SELL)
        polymarketSide = 'BUY' if (side == 'buy') else 'SELL'
        # Convert amount and price to strings
        size = self.number_to_string(amount)
        priceStr = None
        if type == 'limit':
            if price is None:
                raise ArgumentsRequired(self.id + ' buildOrder() requires a price parameter for limit orders')
            priceStr = self.number_to_string(price)
        elif type == 'market':
            # For market orders, price is optional but recommended
            # If not provided, we'll try to fetch from orderbook or use params.marketPrice
            if price is not None:
                priceStr = self.number_to_string(price)
            else:
                # Try to get price from params.marketPrice
                marketPrice = self.safe_number(params, 'marketPrice')
                if marketPrice is not None:
                    priceStr = self.number_to_string(marketPrice)
        # Determine orderType(at top level, not inside order object)
        # Must be determined before building orderObject to set expiration correctly
        orderType = self.safe_string(params, 'timeInForce', 'GTC')
        if type == 'market':
            # For market orders, use IOC(Immediate-Or-Cancel) by default
            # IOC allows partial fills, making it more forgiving than FOK(Fill-Or-Kill)
            # Users can still override with params.timeInForce = 'FOK' if needed
            orderType = self.safe_string(params, 'timeInForce', 'IOC')
        # Set expiration BEFORE signing: for non-GTD orders(GTC, FOK, FAK), expiration must be '0'
        # Only GTD orders should have a timestamp expiration
        # The signature must match the exact expiration value that will be sent to the API
        # See https://docs.polymarket.com/developers/CLOB/orders/create-order#request-payload-parameters
        orderTypeUpper = orderType.upper()
        # For non-GTD orders, expiration MUST be '0'(API requirement)
        # Override any user-provided expiration for non-GTD orders
        orderParams = self.extend({}, params)
        if orderTypeUpper == 'GTD':
            expiration = self.safe_integer(params, 'expiration')
            if expiration is None:
                nowSeconds = int(math.floor(self.milliseconds()) / 1000)
                defaultExpirationDays = self.safe_integer(self.options, 'defaultExpirationDays', 30)
                expiration = nowSeconds + (defaultExpirationDays * 24 * 60 * 60)
            else:
                orderParams['expiration'] = str(expiration)
        else:
            # For non-GTD orders, expiration must be 0(will be converted to "0" string in signing)
            orderParams['expiration'] = 0
        # Pass order type to buildAndSignOrder for market order special handling
        orderParams['orderType'] = type
        # Build and sign the order with EIP-712(pass market to use fees from market)
        signedOrder = await self.build_and_sign_order(tokenId, polymarketSide, size, priceStr, market, orderParams)
        # override signedOrder types
        signedOrder['salt'] = self.parse_to_int(signedOrder['salt'])  # integer not string
        signedOrder['side'] = polymarketSide  # string(BUY or SELL)
        # Get API credentials for owner field
        apiCredentials = self.get_api_credentials()
        owner = self.safe_string(apiCredentials, 'apiKey')
        if owner is None:
            raise AuthenticationError(self.id + ' buildOrder() requires API credentials(apiKey)')
        # Build request payload according to API specification
        # Top-level fields: order, owner, orderType
        requestPayload: dict = {
            'order': signedOrder,
            'owner': owner,
            'orderType': orderType.upper(),
        }
        # Add optional parameters if provided
        clientOrderId = self.safe_string(params, 'clientOrderId')
        if clientOrderId is not None:
            requestPayload['clientOrderId'] = clientOrderId
        postOnly = self.safe_bool(params, 'postOnly', False)
        if postOnly:
            requestPayload['postOnly'] = True
        return requestPayload

    async def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}) -> Order:
        """
        create a trade order

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        https://docs.polymarket.com/developers/CLOB/orders/create-order
        https://github.com/Polymarket/clob-order-utils
        https://docs.polymarket.com/developers/CLOB/orders/create-order#request-payload-parameters

        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency
        :param float [price]: the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID(required if market has multiple outcomes)
        :param str [params.timeInForce]: 'GTC', 'IOC', 'FOK', 'GTD'(default: 'GTC')
        :param str [params.clientOrderId]: a unique id for the order
        :param boolean [params.postOnly]: if True, the order will only be posted to the order book and not executed immediately
        :param number [params.expiration]: expiration timestamp in seconds(default: 30 days from now)
        :param number [params.nonce]: order nonce(default: current timestamp)
        :param number [params.feeRateBps]: fee rate in basis points(default: fetched from API)
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        # Build the order request payload
        requestPayload = await self.build_order(symbol, type, side, amount, price, params)
        # Extract clientOrderId from request payload for return value
        clientOrderId = self.safe_string(requestPayload, 'clientOrderId')
        # Submit order via POST /order endpoint
        response = await self.clob_private_post_order(self.extend(requestPayload, params))
        # Response format:
        # {
        #     "success": boolean,
        #     "errorMsg": string(if error),
        #     "orderId": string,
        #     "orderHashes": string[](if order was marketable)
        # }
        success = self.safe_bool(response, 'success', True)
        if not success:
            errorMsg = self.safe_string(response, 'errorMsg', 'Unknown error')
            raise ExchangeError(self.id + ' createOrder() failed: ' + errorMsg)
        orderId = self.safe_string(response, 'orderID')
        if orderId is None:
            raise ExchangeError(self.id + ' createOrder() response missing orderID')
        market = None
        if symbol:
            market = self.market(symbol)
        # Combine response with order details from requestPayload for parseOrder
        orderData = self.extend({
            'orderID': orderId,
            'clientOrderId': clientOrderId,
            'order': requestPayload['order'],  # Include the signed order for additional context
            'order_type': requestPayload['orderType'],  # Include orderType for parseOrder
        }, response)
        order = self.parse_order(orderData, market)
        return order

    async def create_orders(self, orders: List[OrderRequest], params={}) -> List[Order]:
        """
        create multiple trade orders

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        https://docs.polymarket.com/developers/CLOB/orders/create-order-batch

        :param Array orders: list of orders to create, each order should contain the parameters required by createOrder
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an array of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        orderRequests = []
        clientOrderIds = []
        symbols = []
        for i in range(0, len(orders)):
            order = orders[i]
            symbol = self.safe_string(order, 'symbol')
            if symbol is None:
                raise ArgumentsRequired(self.id + ' createOrders() requires a symbol in each order')
            type = self.safe_string(order, 'type')
            side = self.safe_string(order, 'side')
            amount = self.safe_number(order, 'amount')
            price = self.safe_number(order, 'price')
            orderParams = self.safe_dict(order, 'params', {})
            # Merge order-level params with top-level params
            mergedParams = self.extend({}, params, orderParams)
            # Get token_id from order params, order directly, or it will be resolved in buildOrder
            tokenId = self.safe_string(orderParams, 'token_id') or self.safe_string(order, 'token_id')
            if tokenId is not None:
                mergedParams['token_id'] = tokenId
            # Get clientOrderId from order params or order directly
            clientOrderId = self.safe_string(orderParams, 'clientOrderId') or self.safe_string(order, 'clientOrderId')
            if clientOrderId is not None:
                mergedParams['clientOrderId'] = clientOrderId
            # Get timeInForce from order params or order directly
            timeInForce = self.safe_string(orderParams, 'timeInForce') or self.safe_string(order, 'timeInForce')
            if timeInForce is not None:
                mergedParams['timeInForce'] = timeInForce
            # Build the order request payload using the shared buildOrder function
            orderRequest = await self.build_order(symbol, type, side, amount, price, mergedParams)
            # Store clientOrderId from request payload for response parsing
            requestClientOrderId = self.safe_string(orderRequest, 'clientOrderId')
            clientOrderIds.append(requestClientOrderId)
            symbols.append(symbol)
            orderRequests.append(orderRequest)
        # Submit batch orders via POST /orders endpoint
        response = await self.clob_private_post_orders(self.extend({'orders': orderRequests}, params))
        # Response format: array of order responses, each with:
        # {
        #     "success": boolean,
        #     "errorMsg": string(if error),
        #     "orderId": string,
        #     "orderHashes": string[](if order was marketable)
        # }
        result = []
        for i in range(0, len(response)):
            orderResponse = response[i]
            success = self.safe_bool(orderResponse, 'success', True)
            if not success:
                errorMsg = self.safe_string(orderResponse, 'errorMsg', 'Unknown error')
                raise ExchangeError(self.id + ' createOrders() failed for order ' + i + ': ' + errorMsg)
            orderId = self.safe_string(orderResponse, 'orderID')
            if orderId is None:
                raise ExchangeError(self.id + ' createOrders() response missing orderID for order ' + i)
            market = None
            if symbols[i]:
                market = self.market(symbols[i])
            # Combine response with order details from orderRequests for parseOrder
            orderData = self.extend({
                'orderID': orderId,
                'clientOrderId': clientOrderIds[i],
                'order': orderRequests[i]['order'],  # Include the signed order for additional context
                'order_type': orderRequests[i]['orderType'],  # Include orderType for parseOrder
            }, orderResponse)
            result.append(self.parse_order(orderData, market))
        return result

    async def create_market_order(self, symbol: str, side: OrderSide, amount: float, price: Num = None, params={}):
        """
        create a market order
        :param str symbol: unified symbol of the market to create an order in
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency
        :param float [price]: ignored for market orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        # Use IOC by default for market orders(allows partial fills)
        # Users can override with params.timeInForce = 'FOK' if they need Fill-Or-Kill behavior
        return await self.create_order(symbol, 'market', side, amount, price, self.extend(params, {'timeInForce': 'IOC'}))

    async def cancel_order(self, id: str, symbol: Str = None, params={}) -> Order:
        """
        cancels an open order

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        https://docs.polymarket.com/developers/CLOB/orders/cancel-order

        :param str id: order id
        :param str symbol: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        # Based on cancel() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(CANCEL = "/order")
        # Response format: {canceled: string[], not_canceled: {order_id -> reason}}
        # See https://docs.polymarket.com/developers/CLOB/orders/cancel-order
        response = await self.clob_private_delete_order(self.extend({'order_id': id}, params))
        canceled = self.safe_list(response, 'canceled', [])
        notCanceled = self.safe_dict(response, 'not_canceled', {})
        # Check if order was successfully canceled
        isCanceled = False
        for i in range(0, len(canceled)):
            if canceled[i] == id:
                isCanceled = True
                break
        if isCanceled:
            # Order was canceled, parse order from response data
            market = self.market(symbol) if symbol else None
            orderData = {
                'id': id,
                'status': 'canceled',
                'info': response,
            }
            return self.parse_order(orderData, market)
        else:
            # Check if order is in not_canceled map
            reason = self.safe_string(notCanceled, id)
            if reason is not None:
                # Order couldn't be canceled, raise error with reason
                raise ExchangeError(self.id + ' cancelOrder() failed: ' + reason)
            else:
                # Order ID not found in response(shouldn't happen)
                raise ExchangeError(self.id + ' cancelOrder() unexpected response format')

    async def cancel_orders(self, ids: List[str], symbol: Str = None, params={}) -> List[Order]:
        """
        cancel multiple orders

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        https://docs.polymarket.com/developers/CLOB/orders/cancel-order-batch

        :param str[] ids: order ids
        :param str symbol: unified symbol of the market the orders were made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an array of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        # Based on cancel_orders() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(CANCEL_ORDERS = "/orders")
        # Response format: {canceled: string[], not_canceled: {order_id -> reason}}
        # See https://docs.polymarket.com/developers/CLOB/orders/cancel-order-batch
        response = await self.clob_private_delete_orders(self.extend({'order_ids': ids}, params))
        canceled = self.safe_list(response, 'canceled', [])
        notCanceled = self.safe_dict(response, 'not_canceled', {})
        market = self.market(symbol) if symbol else None
        orders: List[Order] = []
        # Add canceled orders
        for i in range(0, len(canceled)):
            orderId = canceled[i]
            orderData = {
                'id': orderId,
                'status': 'canceled',
                'info': response,
            }
            orders.append(self.parse_order(orderData, market))
        # Verify all requested orders are accounted for in the response
        for i in range(0, len(ids)):
            orderId = ids[i]
            isInCanceled = False
            for j in range(0, len(canceled)):
                if canceled[j] == orderId:
                    isInCanceled = True
                    break
            if not isInCanceled and not (orderId in notCanceled):
                # Order ID not found in response(unexpected)
                raise ExchangeError(self.id + ' cancelOrders() unexpected response format for order ' + orderId)
        return orders

    async def cancel_all_orders(self, symbol: Str = None, params={}) -> List[Order]:
        """
        cancel all open orders

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        https://docs.polymarket.com/developers/CLOB/orders/cancel-all-orders

        :param str [symbol]: unified market symbol, only orders in the market of self symbol are cancelled when symbol is not None
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        response
        if symbol is not None:
            # Use cancel-market-orders endpoint when symbol is provided
            # See https://docs.polymarket.com/developers/CLOB/orders/cancel-market-orders
            market = self.market(symbol)
            marketInfo = self.safe_dict(market, 'info', {})
            # Get condition_id(market ID)
            conditionId = self.safe_string(marketInfo, 'condition_id', market['id'])
            # Get asset_id from clobTokenIds
            clobTokenIds = self.safe_value(marketInfo, 'clobTokenIds', [])
            request: dict = {}
            if conditionId is not None:
                request['market'] = conditionId
            if len(clobTokenIds) > 0:
                request['asset_id'] = clobTokenIds[0]
            # Response format: {canceled: string[], not_canceled: {order_id -> reason}}
            response = await self.clob_private_delete_cancel_market_orders(self.extend(request, params))
        else:
            # Use cancel-all endpoint when symbol is None
            # Based on cancel_all() from py-clob-client
            # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(CANCEL_ALL = "/cancel-all")
            # Response format: {canceled: string[], not_canceled: {order_id -> reason}}
            # See https://docs.polymarket.com/developers/CLOB/orders/cancel-all-orders
            response = await self.clob_private_delete_cancel_all(params)
        canceled = self.safe_list(response, 'canceled', [])
        orderMarket = self.market(symbol) if symbol else None
        orders: List[Order] = []
        # Add canceled orders
        for i in range(0, len(canceled)):
            orderId = canceled[i]
            orderData = {
                'id': orderId,
                'status': 'canceled',
                'info': response,
            }
            orders.append(self.parse_order(orderData, orderMarket))
        return orders

    async def fetch_order(self, id: str, symbol: Str = None, params={}) -> Order:
        """
        fetches information on an order made by the user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        https://docs.polymarket.com/developers/CLOB/orders/get-order

        :param str id: order id
        :param str symbol: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        # Based on get_order() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(GET_ORDER = "/data/order/")
        response = await self.clob_private_get_order(self.extend({'order_id': id}, params))
        market = self.market(symbol) if symbol else None
        return self.parse_order(response, market)

    async def fetch_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        fetches information on multiple orders made by the user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        https://docs.polymarket.com/developers/CLOB/orders/get-orders

        :param str symbol: unified symbol of the market the orders were made in
        :param int [since]: the earliest time in ms to fetch orders for
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.id]: filter orders by order id
        :param str [params.market]: filter orders by market id
        :param str [params.asset_id]: filter orders by asset id(alias token_id)
        :returns dict[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        await self.ensure_api_credentials(params)
        request = {}
        if symbol is not None:
            market = self.market(symbol)
            marketInfo = self.safe_dict(market, 'info', {})
            # Filter by condition_id(market) to get all orders for self market
            # This is more appropriate than filtering by asset_id alone, market can have multiple outcomes
            conditionId = self.safe_string(marketInfo, 'condition_id', market['id'])
            if conditionId is not None:
                request['market'] = conditionId
            # Also include asset_id for backward compatibility and more specific filtering
            clobTokenIds = self.safe_value(marketInfo, 'clobTokenIds', [])
            if len(clobTokenIds) > 0:
                # The Polymarket L2 getOpenOrders() endpoint filters by asset_id
                request['asset_id'] = clobTokenIds[0]
                # Keep backward compatibility for legacy token_id usage
                request['token_id'] = clobTokenIds[0]
        id = self.safe_string(params, 'id')
        if id is not None:
            request['id'] = id
        marketId = self.safe_string(params, 'market')
        if marketId is not None:
            request['market'] = marketId
        assetId = self.safe_string_2(params, 'asset_id', 'token_id')
        if assetId is not None:
            request['asset_id'] = assetId
            request['token_id'] = assetId
        initialCursor = self.safe_string(self.options, 'initialCursor')
        endCursor = self.safe_string(self.options, 'endCursor')
        nextCursor = initialCursor
        ordersResponse: List[Any] = []
        while(True):
            response = await self.clob_private_get_orders(self.extend(request, {'next_cursor': nextCursor}, params))
            data = self.safe_list(response, 'data', [])
            ordersResponse = self.array_concat(ordersResponse, data)
            if limit is not None and len(ordersResponse) >= limit:
                break
            nextCursor = self.safe_string(response, 'next_cursor')
            if nextCursor is None or nextCursor == endCursor:
                break
        orderMarket = self.market(symbol) if symbol else None
        return self.parse_orders(ordersResponse, orderMarket, since, limit)

    async def fetch_open_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        fetch all unfilled currently open orders
        :param str symbol: unified symbol of the market to fetch open orders for
        :param int [since]: the earliest time in ms to fetch open orders for
        :param int [limit]: the maximum number of open order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        # The Polymarket getOpenOrders() endpoint already returns open orders
        return await self.fetch_orders(symbol, since, limit, params)

    def parse_order(self, order: dict, market: Market = None) -> Order:
        """
        parses an order from the exchange response format
        :param dict order: order response from the exchange
        :param dict [market]: market structure
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        # Handle createOrder/createOrders response format:
        # {
        #   "success": boolean,
        #   "errorMsg": string(if error),
        #   "orderID": string,
        #   "orderHashes": string[](if order was marketable)
        # }
        # Or fetchOrder response format(OpenOrder interface):
        # {
        #   id: string
        #   status: string
        #   owner: string
        #   maker_address: string
        #   market: string
        #   asset_id: string
        #   side: string
        #   original_size: string
        #   size_matched: string
        #   price: string
        #   associate_trades: string[]
        #   outcome: string
        #   created_at: number  # seconds
        #   expiration: string
        #   order_type: string
        # }
        id = self.safe_string(order, 'id')
        # Handle createOrder response format(has orderID instead of id)
        if id is None:
            id = self.safe_string(order, 'orderID')
        marketId = self.safe_string(order, 'market')
        assetId = self.safe_string(order, 'asset_id')
        if market is None and marketId is not None:
            market = self.safe_market(marketId, None)
        symbol = None
        if market is not None and market['symbol'] is not None:
            symbol = market['symbol']
        elif assetId is not None:
            symbol = assetId
        # Handle createOrder response - get side from order object if available
        sideStr = self.safe_string_lower(order, 'side')
        # If side is not in order, try to get it from the order object passed in createOrder
        if sideStr is None:
            orderObj = self.safe_dict(order, 'order')
            if orderObj is not None:
                sideStr = self.safe_string_lower(orderObj, 'side')
        side = sideStr if (sideStr == 'buy' or sideStr == 'sell') else None
        orderType = self.safe_string(order, 'order_type')
        # Handle createOrder response - get orderType from order object if available
        if orderType is None:
            orderObj = self.safe_dict(order, 'order')
            if orderObj is not None:
                orderType = self.safe_string(orderObj, 'orderType')
            # Also check at top level(from requestPayload)
            if orderType is None:
                orderType = self.safe_string(order, 'orderType')
        # Normalize orderType to lowercase for consistent parsing
        if orderType is not None:
            orderType = orderType.lower()
        # Amounts
        amount = self.safe_number(order, 'original_size')
        # Handle createOrder response - get amount from order object if available
        if amount is None:
            orderObj = self.safe_dict(order, 'order')
            if orderObj is not None:
                amount = self.safe_number(orderObj, 'size')
        filled = self.safe_number(order, 'size_matched')
        remaining = self.safe_number(order, 'remaining_size')
        if remaining is None and amount is not None and filled is not None:
            remaining = amount - filled
        # Price
        price = self.safe_number(order, 'price')
        # Handle createOrder response - get price from order object if available
        if price is None:
            orderObj = self.safe_dict(order, 'order')
            if orderObj is not None:
                price = self.safe_number(orderObj, 'price')
        # Status
        statusStr = self.safe_string(order, 'status', '')
        status = self.parse_order_status(statusStr)
        # Timestamps(created_at is seconds)
        createdAt = self.safe_integer(order, 'created_at')
        timestamp = createdAt * 1000 if (createdAt is not None) else None
        # Get clientOrderId from order or from the order object
        clientOrderId = self.safe_string(order, 'clientOrderId')
        if clientOrderId is None:
            orderObj = self.safe_dict(order, 'order')
            if orderObj is not None:
                clientOrderId = self.safe_string(orderObj, 'clientOrderId')
        # No explicit updated_at in interface; leave lastTradeTimestamp None
        return self.safe_order({
            'id': id,
            'clientOrderId': clientOrderId,
            'info': order,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp) if timestamp else None,
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': symbol,
            'type': self.parse_order_type(orderType),
            'timeInForce': self.parse_time_in_force(orderType),
            'side': side,
            'price': price,
            'amount': amount,
            'cost': None,
            'average': None,
            'filled': filled,
            'remaining': remaining,
            'fee': None,
        }, market)

    def parse_order_status(self, status: Str) -> Str:
        """
        parse the status of an order
        :param str status: order status from exchange
        :returns str: a unified order status
        """
        if status is None or status == '':
            return 'open'  # Default to 'open' if no status is provided
        statuses: dict = {
            # https://docs.polymarket.com/developers/CLOB/orders/create-order#status
            'matched': 'closed',   # order placed and matched with an existing resting order
            'live': 'open',         # order placed and resting on the book
            'delayed': 'open',      # order marketable, but subject to matching delay
            'unmatched': 'open',    # order marketable, but failure delaying, placement successful
            'canceled': 'canceled',  # CCXT unified status for canceled orders
        }
        normalizedStatus = status.lower()
        return self.safe_string(statuses, normalizedStatus, normalizedStatus)

    def parse_order_type(self, type: Str) -> Str:
        types: dict = {
            'fok': 'market',  # Fill-Or-Kill: market order
            'fak': 'market',  # Fill-And-Kill: market order
            'ioc': 'market',  # Immediate-Or-Cancel: market order
            'gtc': 'limit',  # Good-Til-Cancelled: limit order
            'gtd': 'limit',  # Good-Til-Date: limit order
        }
        return self.safe_string(types, type, 'limit')

    def parse_time_in_force(self, timeInForce: Str) -> Str:
        if timeInForce is None:
            return None
        timeInForces: dict = {
            'fok': 'FOK',  # Fill-Or-Kill
            'fak': 'FAK',  # Fill-And-Kill
            'ioc': 'IOC',  # Immediate-Or-Cancel
            'gtc': 'GTC',  # Good-Til-Cancelled
            'gtd': 'GTD',  # Good-Til-Date
        }
        normalized = timeInForce.lower()
        mapped = self.safe_string(timeInForces, normalized)
        return mapped is not mapped if None else timeInForce.upper()

    async def fetch_time(self, params={}) -> Int:
        """
        fetches the current integer timestamp in milliseconds from the exchange server

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py#L178

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns int: the current integer timestamp in milliseconds from the exchange server
        """
        # Based on get_server_time() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py#L178
        response = await self.clob_public_get_time(params)
        # Response format: timestamp in seconds(Unix timestamp)
        # Convert to milliseconds for CCXT standard
        timestamp = self.safe_integer(response, 'timestamp')
        if timestamp is not None:
            return timestamp * 1000  # Convert seconds to milliseconds
        # Fallback: if response is just a number
        if isinstance(response, numbers.Real):
            return response * 1000
        # Fallback: use current time if server time not available
        return self.milliseconds()

    async def fetch_status(self, params={}):
        """
        the latest known information on the availability of the exchange API

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py#L170

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `status structure <https://docs.ccxt.com/#/?id=exchange-status-structure>`
        """
        # Based on get_ok() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py#L170
        try:
            await self.clob_public_get_ok(params)
            return {
                'status': 'ok',
                'updated': None,
                'eta': None,
                'url': None,
            }
        except Exception as e:
            return {
                'status': 'error',
                'updated': None,
                'eta': None,
                'url': None,
            }

    async def fetch_trading_fee(self, symbol: str, params={}) -> TradingFeeInterface:
        """
        fetches the trading fee for a market

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py

        :param str symbol: unified symbol of the market to fetch the fee for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID(required if not in market info)
        :returns dict: a `fee structure <https://docs.ccxt.com/#/?id=fee-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        marketInfo = self.safe_dict(market, 'info', {})
        # Get token ID from params or market info
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            clobTokenIds = self.safe_value(marketInfo, 'clobTokenIds', [])
            if len(clobTokenIds) > 0:
                tokenId = clobTokenIds[0]
            else:
                raise ArgumentsRequired(self.id + ' fetchTradingFee() requires a token_id parameter for market ' + symbol)
        # Based on get_fee_rate() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        response = await self.clob_public_get_fee_rate(self.extend({'token_id': tokenId}, params))
        # Response format: {"fee_rate": "0.02"} or {"fee_rate_bps": 200}(basis points)
        feeRate = self.safe_string(response, 'fee_rate')
        feeRateBps = self.safe_integer(response, 'fee_rate_bps')
        maker: Num = None
        taker: Num = None
        if feeRate is not None:
            fee = self.parse_number(feeRate)
            maker = fee
            taker = fee
        elif feeRateBps is not None:
            # Convert basis points to percentage(200 bps = 2% = 0.02)
            fee = self.parse_number(feeRateBps) / 10000
            maker = fee
            taker = fee
        else:
            # Default fee from describe() if not available
            maker = self.safe_number(self.fees['trading'], 'maker')
            taker = self.safe_number(self.fees['trading'], 'taker')
        # Ensure we have valid numbers(fallback to default if None)
        makerFee: Num = maker is not maker if None else self.parse_number('0.02')
        takerFee: Num = taker is not taker if None else self.parse_number('0.02')
        result: TradingFeeInterface = {
            'info': response,
            'symbol': symbol,
            'maker': makerFee,
            'taker': takerFee,
            'percentage': True,
            'tierBased': False,
        }
        return result

    async def fetch_open_interest(self, symbol: str, params={}):
        """
        retrieves the open interest of a market

        https://docs.polymarket.com/api-reference/misc/get-open-interest

        :param str symbol: unified CCXT market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure:
        """
        await self.load_markets()
        market = self.market(symbol)
        marketInfo = self.safe_dict(market, 'info', {})
        conditionId = self.safe_string(marketInfo, 'condition_id', market['id'])
        # API expects market of condition IDs
        request: dict = {
            'market': [conditionId],
        }
        response = await self.data_public_get_open_interest(self.extend(request, params))
        return self.parse_open_interest(response, market)

    def parse_open_interest(self, interest: dict, market: Market = None):
        """
        parses open interest data from the exchange response format
        :param dict interest: open interest data from the exchange
        :param dict [market]: the market self open interest is for
        :returns dict} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure:
        """
        # Polymarket Data API /oi response format
        # Response is an array of objects with market(condition ID) and value
        # Example response structure:
        # [
        #   {
        #     "market": "0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917",
        #     "value": 123
        #   }
        # ]
        timestamp = self.milliseconds()
        # Handle array response
        openInterestData: dict = {}
        if isinstance(interest, list):
            # For single symbol query, get the first item
            if len(interest) > 0:
                openInterestData = interest[0]
        elif isinstance(interest, dict) and interest != None:
            # Fallback: handle object response if API changes
            openInterestData = interest
        # Extract open interest value from the response
        # API returns "value" field which represents the open interest value
        openInterestValue = self.safe_number(openInterestData, 'value', 0)
        # For Polymarket, value is typically in USDC, so we use it amount and value
        # If we need to distinguish, we could parse additional fields if available
        return self.safe_open_interest({
            'symbol': market['symbol'] if market else None,
            'openInterestAmount': openInterestValue,  # Using value since API only provides value
            'openInterestValue': openInterestValue,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'info': interest,
        }, market)

    async def fetch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        fetch all trades made by the user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py

        :param str symbol: unified symbol of the market to fetch trades for
        :param int [since]: the earliest time in ms to fetch trades for
        :param int [limit]: the maximum number of trades structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.market]: filter trades by market(condition_id)
        :param str [params.asset_id]: filter trades by asset ID
        :param str [params.id]: filter by trade id
        :param str [params.maker_address]: filter by maker address
        :param str [params.before]: pagination cursor(see API docs)
        :param str [params.after]: pagination cursor(see API docs)
        :param str [params.next_cursor]: pagination cursor(default: "MA==")
        :returns Trade[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        request: dict = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            marketInfo = self.safe_dict(market, 'info', {})
            # Filter by condition_id(market) to get all trades for self market
            # Don't automatically add asset_id filter would restrict to only one outcome
            conditionId = self.safe_string(marketInfo, 'condition_id', self.safe_string(market, 'id'))
            if conditionId is not None:
                request['market'] = conditionId
        # Backward compatibility: token_id alias to asset_id
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is not None:
            request['asset_id'] = tokenId
        marketId = self.safe_string(params, 'market')
        if marketId is not None:
            request['market'] = marketId
        assetId = self.safe_string_2(params, 'asset_id', 'assetId')
        if assetId is not None:
            request['asset_id'] = assetId
        id = self.safe_string(params, 'id')
        if id is not None:
            request['id'] = id
        makerAddress = self.safe_string_2(params, 'maker_address', 'makerAddress')
        if makerAddress is not None:
            request['maker_address'] = makerAddress
        before = self.safe_string(params, 'before')
        if before is not None:
            request['before'] = before
        after = self.safe_string(params, 'after')
        if after is not None:
            request['after'] = after
        if since is not None:
            # Map ccxt since to Polymarket's "after" cursor using seconds
            request['after'] = self.number_to_string(int(math.floor(since / 1000)))
        if limit is not None:
            request['limit'] = limit
        results: List[Any] = []
        initialCursor = self.safe_string(self.options, 'initialCursor')
        endCursor = self.safe_string(self.options, 'endCursor')
        next_cursor = initialCursor
        while(next_cursor != endCursor):
            response = await self.clob_private_get_trades(self.extend(request, {'next_cursor': next_cursor}, params))
            next_cursor = self.safe_string(response, 'next_cursor', endCursor)
            data = self.safe_list(response, 'data', []) or []
            results = self.array_concat(results, data)
            if limit is not None and len(results) >= limit:
                break
        return self.parse_trades(results, market, since, limit)

    async def fetch_user_trades(self, user: str, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        fetch trades for a specific user

        https://docs.polymarket.com/api-reference/core/get-trades-for-a-user-or-markets

        :param str user: user address(0x-prefixed, 40 hex chars)
        :param str [symbol]: unified symbol of the market to fetch trades for
        :param int [since]: timestamp in ms of the earliest trade to fetch
        :param int [limit]: the maximum amount of trades to fetch(default: 100, max: 10000)
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.offset]: offset for pagination(default: 0, max: 10000)
        :param boolean [params.takerOnly]: if True, returns only trades where the user is the taker(default: True)
        :param str [params.side]: filter by side: 'BUY' or 'SELL'
        :param str[] [params.market]: comma-separated list of condition IDs(mutually exclusive with symbol)
        :param int[] [params.eventId]: comma-separated list of event IDs(mutually exclusive with market)
        :returns Trade[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        await self.load_markets()
        request: dict = {
            'user': user,
        }
        market = None
        if symbol is not None:
            market = self.market(symbol)
            marketInfo = self.safe_dict(market, 'info', {})
            conditionId = self.safe_string(marketInfo, 'condition_id', market['id'])
            request['market'] = [conditionId]
        marketParam = self.safe_value(params, 'market')
        if marketParam is not None:
            # Convert to array if it's a string or single value
            if isinstance(marketParam, list):
                request['market'] = marketParam
            else:
                request['market'] = [marketParam]
        eventId = self.safe_value(params, 'eventId')
        if eventId is not None:
            if isinstance(eventId, list):
                request['eventId'] = eventId
            else:
                request['eventId'] = [eventId]
        if limit is not None:
            request['limit'] = min(limit, 10000)  # Cap at max 10000
        offset = self.safe_integer(params, 'offset')
        if offset is not None:
            request['offset'] = offset
        takerOnly = self.safe_bool(params, 'takerOnly', True)
        request['takerOnly'] = takerOnly
        side = self.safe_string_upper(params, 'side')
        if side is not None:
            request['side'] = side
        response = await self.data_public_get_trades(self.extend(request, self.omit(params, ['market', 'eventId', 'offset', 'takerOnly', 'side'])))
        tradesData = []
        if isinstance(response, list):
            tradesData = response
        else:
            dataList = self.safe_list(response, 'data', [])
            if dataList is not None:
                tradesData = dataList
        return self.parse_trades(tradesData, market, since, limit)

    async def fetch_balance(self, params={}):
        """
        fetches balance and allowance for the authenticated user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        https://docs.polymarket.com/developers/CLOB/clients/methods-l2#getbalanceallowance

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.asset_type]: asset type: 'COLLATERAL'(default) or 'CONDITIONAL'
        :param str [params.token_id]: token ID, default: from options.defaultTokenId)
        :param int [params.signature_type]: signature type(default: from options.signatureType or options.signatureTypes.EOA).
        :returns dict: a `balance structure <https://docs.ccxt.com/#/?id=balance-structure>`
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        # Default asset_type to COLLATERAL if not provided
        assetType = self.safe_string(params, 'asset_type', 'COLLATERAL')
        params['asset_type'] = assetType
        # Use signature_type from params or fall back to options
        signatureType = self.get_signature_type(params)
        request: dict = {
            'asset_type': assetType,
        }
        if signatureType is not None:
            request['signature_type'] = signatureType
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            defaultTokenId = self.safe_string(self.options, 'defaultTokenId')
            if defaultTokenId is not None:
                request['token_id'] = defaultTokenId
        else:
            request['token_id'] = tokenId
        # Fetch balance and allowance from CLOB endpoint
        clobResponse = await self.clob_private_get_balance_allowance(request)
        #
        #     {
        #         "balance": "1000000",
        #         "allowance": "0"
        #     }
        #
        balance = self.safe_string(clobResponse, 'balance')
        allowance = self.safe_string(clobResponse, 'allowance')
        collateral = self.safe_string(self.options, 'defaultCollateral', 'USDC')
        # Convert CLOB balance and allowance(6 decimals) to standard units
        collateralTotalValue = None
        collateralUsedValue = None
        collateralFreeValue = None
        if balance is not None:
            parsedBalance = self.parse_number(balance)
            if parsedBalance is not None:
                collateralTotalValue = parsedBalance / 1000000
        if allowance is not None:
            parsedAllowance = self.parse_number(allowance)
            if parsedAllowance is not None:
                collateralUsedValue = parsedAllowance / 1000000
        # Calculate free balance: total - used(allowance)
        if collateralTotalValue is not None and collateralUsedValue is not None:
            collateralFreeValue = collateralTotalValue - collateralUsedValue
        elif collateralTotalValue is not None:
            collateralFreeValue = collateralTotalValue
        result: dict = {
            'info': clobResponse,
        }
        if collateralTotalValue is not None:
            account = self.account()
            account['total'] = collateralTotalValue
            if collateralFreeValue is not None:
                account['free'] = collateralFreeValue
            if collateralUsedValue is not None:
                account['used'] = collateralUsedValue
            result[collateral] = account
        return self.safe_balance(result)

    async def get_notifications(self, params={}):
        """
        fetches notifications for the authenticated user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.signature_type]: signature type(default: from options.signatureType or options.signatureTypes.EOA).
        :returns dict: response from the exchange
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        # Use signature_type from params or fall back to options
        signatureType = self.get_signature_type(params)
        request: dict = {}
        if signatureType is not None:
            request['signature_type'] = signatureType
        # Based on get_notifications() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        response = await self.clob_private_get_notifications(self.extend(request, params))
        return response

    async def drop_notifications(self, params={}):
        """
        drops notifications for the authenticated user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.notification_id]: specific notification ID to drop(optional)
        :param int [params.signature_type]: signature type(default: from options.signatureType or options.signatureTypes.EOA).
        :returns dict: response from the exchange
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        # Use signature_type from params or fall back to options
        signatureType = self.get_signature_type(params)
        request: dict = {}
        if signatureType is not None:
            request['signature_type'] = signatureType
        # Based on drop_notifications() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        response = await self.clob_private_delete_notifications(self.extend(request, params))
        return response

    async def get_balance_allowance(self, params={}):
        """
        fetches balance and allowance for the authenticated user(alias for fetchBalance)

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        https://docs.polymarket.com/developers/CLOB/clients/methods-l2#getbalanceallowance

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.asset_type]: asset type: 'COLLATERAL'(default) or 'CONDITIONAL'
        :param str [params.token_id]: token ID, default: from options.defaultTokenId)
        :param int [params.signature_type]: signature type(default: from options.signatureType or options.signatureTypes.EOA).
        :returns dict: response from the exchange
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        # Alias for fetchBalance, but returns raw response
        # Use signature_type from params or fall back to options
        if self.safe_integer(params, 'signature_type') is None:
            signatureType = self.get_signature_type(params)
            if signatureType is not None:
                params['signature_type'] = signatureType
        # Default asset_type to COLLATERAL if not provided(for USDC balance)
        assetType = self.safe_string(params, 'asset_type', 'COLLATERAL')
        params['asset_type'] = assetType
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            defaultTokenId = self.safe_string(self.options, 'defaultTokenId')
            if defaultTokenId is not None:
                params['token_id'] = defaultTokenId
        else:
            params['token_id'] = tokenId
        return await self.clob_private_get_balance_allowance(params)

    async def update_balance_allowance(self, params={}):
        """
        updates balance and allowance for the authenticated user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.signature_type]: signature type(default: from options.signatureType or options.signatureTypes.EOA).
        :returns dict: response from the exchange
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        # Based on update_balance_allowance() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        # Use signature_type from params or fall back to options
        if self.safe_integer(params, 'signature_type') is None:
            signatureType = self.get_signature_type(params)
            if signatureType is not None:
                params['signature_type'] = signatureType
        response = await self.clob_private_put_balance_allowance(params)
        return response

    async def is_order_scoring(self, params={}):
        """
        checks if an order is currently scoring

        https://docs.polymarket.com/developers/CLOB/orders/check-scoring#check-order-reward-scoring

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.order_id]: the order ID to check(required)
        :returns dict: response from the exchange indicating if order is scoring
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        orderId = self.safe_string(params, 'order_id')
        if orderId is None:
            raise ArgumentsRequired(self.id + ' isOrderScoring() requires an order_id parameter')
        response = await self.clob_private_get_is_order_scoring(params)
        # Response: {scoring: boolean}
        return response

    async def are_orders_scoring(self, params={}):
        """
        checks if multiple orders are currently scoring

        https://docs.polymarket.com/developers/CLOB/orders/check-scoring#check-order-reward-scoring

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str[] [params.order_ids]: array of order IDs to check(required)
        :returns dict: response from the exchange indicating which orders are scoring
        """
        await self.load_markets()
        # Ensure API credentials are generated(lazy generation)
        await self.ensure_api_credentials(params)
        orderIds = self.safe_value_2(params, 'order_ids', 'orderIds')
        if orderIds is None or not isinstance(orderIds, list):
            raise ArgumentsRequired(self.id + ' areOrdersScoring() requires an order_ids parameter(array of order IDs)')
        response = await self.clob_private_post_are_orders_scoring(self.extend({'orderIds': orderIds}, params))
        # Response: {orderId: boolean, ...}
        return response

    async def clob_public_get_markets(self, params={}):
        """
        fetches markets from CLOB API(matches clob-client getMarkets())

        https://github.com/Polymarket/clob-client/blob/main/src/client.ts

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.next_cursor]: pagination cursor(default: options.initialCursor)
        :returns dict: response from the exchange
        """
        # Pass api ['clob', 'public'] to match the expected format
        # The api parameter should be an array [api_type, access_level] for exchanges with multiple API types
        return await self.request('markets', ['clob', 'public'], 'GET', self.extend({'api_type': 'clob'}, params))

    async def gamma_public_get_markets(self, params={}):
        """
        fetches markets from Gamma API
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: response from the exchange
        """
        # Pass api ['gamma', 'public'] to match the expected format
        # The api parameter should be an array [api_type, access_level] for exchanges with multiple API types
        return await self.request('markets', ['gamma', 'public'], 'GET', self.extend({'api_type': 'gamma'}, params))

    async def gamma_public_get_markets_id(self, params={}):
        """
        fetches a specific market by ID from Gamma API
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: response from the exchange
        """
        id = self.safe_string(params, 'id')
        if id is None:
            raise ArgumentsRequired(self.id + ' gammaPublicGetMarketsId() requires an id parameter')
        path = 'markets/' + self.encode_uri_component(id)
        remainingParams = self.extend({'api_type': 'gamma'}, self.omit(params, 'id'))
        return await self.request(path, ['gamma', 'public'], 'GET', remainingParams)

    async def gamma_public_get_markets_id_tags(self, params={}):
        """
        fetches tags for a specific market by ID from Gamma API

        https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.id]: the market ID(required)
        :returns dict: response from the exchange
        """
        id = self.safe_string(params, 'id')
        if id is None:
            raise ArgumentsRequired(self.id + ' gammaPublicGetMarketsIdTags() requires an id parameter')
        path = 'markets/' + self.encode_uri_component(id) + '/tags'
        remainingParams = self.extend({'api_type': 'gamma'}, self.omit(params, 'id'))
        return await self.request(path, ['gamma', 'public'], 'GET', remainingParams)

    async def gamma_public_get_markets_slug_slug(self, params={}):
        """
        fetches a specific market by slug from Gamma API

        https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.slug]: the market slug(required)
        :returns dict: response from the exchange
        """
        slug = self.safe_string(params, 'slug')
        if slug is None:
            raise ArgumentsRequired(self.id + ' gammaPublicGetMarketsSlugSlug() requires a slug parameter')
        path = 'markets/slug/' + self.encode_uri_component(slug)
        remainingParams = self.extend({'api_type': 'gamma'}, self.omit(params, 'slug'))
        return await self.request(path, ['gamma', 'public'], 'GET', remainingParams)

    async def gamma_public_get_events(self, params={}):
        """
        fetches events from Gamma API

        https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.limit]: maximum number of results to return
        :param int [params.offset]: offset for pagination
        :param str [params.category]: filter by category
        :param str [params.slug]: filter by slug
        :returns dict: response from the exchange
        """
        return await self.request('events', ['gamma', 'public'], 'GET', self.extend({'api_type': 'gamma'}, params))

    async def gamma_public_get_events_id(self, params={}):
        """
        fetches a specific event by ID from Gamma API

        https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.id]: the event ID(required)
        :returns dict: response from the exchange
        """
        id = self.safe_string(params, 'id')
        if id is None:
            raise ArgumentsRequired(self.id + ' gammaPublicGetEventsId() requires an id parameter')
        path = 'events/' + self.encode_uri_component(id)
        remainingParams = self.extend({'api_type': 'gamma'}, self.omit(params, 'id'))
        return await self.request(path, ['gamma', 'public'], 'GET', remainingParams)

    async def gamma_public_get_series(self, params={}):
        """
        fetches series from Gamma API

        https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.limit]: maximum number of results to return
        :param int [params.offset]: offset for pagination
        :param str [params.category]: filter by category
        :param str [params.slug]: filter by slug
        :returns dict: response from the exchange
        """
        return await self.request('series', ['gamma', 'public'], 'GET', self.extend({'api_type': 'gamma'}, params))

    async def gamma_public_get_series_id(self, params={}):
        """
        fetches a specific series by ID from Gamma API

        https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.id]: the series ID(required)
        :returns dict: response from the exchange
        """
        id = self.safe_string(params, 'id')
        if id is None:
            raise ArgumentsRequired(self.id + ' gammaPublicGetSeriesId() requires an id parameter')
        path = 'series/' + self.encode_uri_component(id)
        remainingParams = self.extend({'api_type': 'gamma'}, self.omit(params, 'id'))
        return await self.request(path, ['gamma', 'public'], 'GET', remainingParams)

    async def gamma_public_get_search(self, params={}):
        """
        performs a full-text search across events, tags, and user profiles from Gamma API

        https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.q]: search query(required)
        :param str [params.type]: filter by type: 'event', 'tag', 'user', etc.
        :param int [params.limit]: maximum number of results to return
        :param int [params.offset]: offset for pagination
        :returns dict: response from the exchange
        """
        q = self.safe_string(params, 'q')
        if q is None:
            raise ArgumentsRequired(self.id + ' gammaPublicGetSearch() requires a q(query) parameter')
        return await self.request('search', ['gamma', 'public'], 'GET', self.extend({'api_type': 'gamma'}, params))

    async def gamma_public_get_comments(self, params={}):
        """
        fetches comments from Gamma API

        https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.event_id]: filter by event ID
        :param str [params.series_id]: filter by series ID
        :param int [params.limit]: maximum number of results to return
        :param int [params.offset]: offset for pagination
        :returns dict: response from the exchange
        """
        return await self.request('comments', ['gamma', 'public'], 'GET', self.extend({'api_type': 'gamma'}, params))

    async def gamma_public_get_comments_id(self, params={}):
        """
        fetches a specific comment by ID from Gamma API

        https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.id]: the comment ID(required)
        :returns dict: response from the exchange
        """
        id = self.safe_string(params, 'id')
        if id is None:
            raise ArgumentsRequired(self.id + ' gammaPublicGetCommentsId() requires an id parameter')
        path = 'comments/' + self.encode_uri_component(id)
        remainingParams = self.extend({'api_type': 'gamma'}, self.omit(params, 'id'))
        return await self.request(path, ['gamma', 'public'], 'GET', remainingParams)

    async def gamma_public_get_sports(self, params={}):
        """
        fetches sports data from Gamma API

        https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.league]: filter by league
        :param str [params.team]: filter by team
        :param int [params.limit]: maximum number of results to return
        :param int [params.offset]: offset for pagination
        :returns dict: response from the exchange
        """
        return await self.request('sports', ['gamma', 'public'], 'GET', self.extend({'api_type': 'gamma'}, params))

    async def gamma_public_get_sports_id(self, params={}):
        """
        fetches a specific sport/team by ID from Gamma API

        https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.id]: the sport/team ID(required)
        :returns dict: response from the exchange
        """
        id = self.safe_string(params, 'id')
        if id is None:
            raise ArgumentsRequired(self.id + ' gammaPublicGetSportsId() requires an id parameter')
        path = 'sports/' + self.encode_uri_component(id)
        remainingParams = self.extend({'api_type': 'gamma'}, self.omit(params, 'id'))
        return await self.request(path, ['gamma', 'public'], 'GET', remainingParams)

    async def data_public_get_positions(self, params={}):
        """
        fetches current positions for a user from Data-API

        https://docs.polymarket.com/api-reference/core/get-current-positions-for-a-user

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.user]: user address(required)
        :param str[] [params.market]: comma-separated list of condition IDs(mutually exclusive with eventId)
        :param int[] [params.eventId]: comma-separated list of event IDs(mutually exclusive with market)
        :param number [params.sizeThreshold]: minimum size threshold(default: 1)
        :param boolean [params.redeemable]: filter by redeemable positions(default: False)
        :param boolean [params.mergeable]: filter by mergeable positions(default: False)
        :param int [params.limit]: maximum number of results(default: 100, max: 500)
        :param int [params.offset]: offset for pagination(default: 0, max: 10000)
        :param str [params.sortBy]: sort field: CURRENT, INITIAL, TOKENS, CASHPNL, PERCENTPNL, TITLE, RESOLVING, PRICE, AVGPRICE(default: TOKENS)
        :param str [params.sortDirection]: sort direction: ASC, DESC(default: DESC)
        :param str [params.title]: filter by title(max length: 100)
        :returns dict: response from the exchange
        """
        user = self.safe_string(params, 'user')
        if user is None:
            raise ArgumentsRequired(self.id + ' dataPublicGetPositions() requires a user parameter')
        return await self.request('positions', ['data', 'public'], 'GET', self.extend({'api_type': 'data'}, params))

    async def data_public_get_trades(self, params={}):
        """
        fetches trades for a user or markets from Data-API

        https://docs.polymarket.com/api-reference/core/get-trades-for-a-user-or-markets

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.user]: user address(optional, filter by user)
        :param str[] [params.market]: comma-separated list of condition IDs(optional, filter by markets)
        :param int [params.limit]: maximum number of results
        :param int [params.offset]: offset for pagination
        :returns dict: response from the exchange
        """
        return await self.request('trades', ['data', 'public'], 'GET', self.extend({'api_type': 'data'}, params))

    async def data_public_get_activity(self, params={}):
        """
        fetches user activity from Data-API

        https://docs.polymarket.com/api-reference/core/get-user-activity

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.user]: user address(required)
        :param int [params.limit]: maximum number of results
        :param int [params.offset]: offset for pagination
        :returns dict: response from the exchange
        """
        user = self.safe_string(params, 'user')
        if user is None:
            raise ArgumentsRequired(self.id + ' dataPublicGetActivity() requires a user parameter')
        return await self.request('activity', ['data', 'public'], 'GET', self.extend({'api_type': 'data'}, params))

    async def data_public_get_holders(self, params={}):
        """
        fetches top holders for markets from Data-API

        https://docs.polymarket.com/api-reference/core/get-top-holders-for-markets

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str[] [params.market]: comma-separated list of condition IDs(required)
        :param int [params.limit]: maximum number of results
        :param int [params.offset]: offset for pagination
        :returns dict: response from the exchange
        """
        market = self.safe_string(params, 'market')
        if market is None:
            raise ArgumentsRequired(self.id + ' dataPublicGetHolders() requires a market parameter')
        return await self.request('holders', ['data', 'public'], 'GET', self.extend({'api_type': 'data'}, params))

    async def data_public_get_total_value(self, params={}):
        """
        fetches total value of a user's positions from Data-API

        https://docs.polymarket.com/api-reference/core/get-total-value-of-a-users-positions

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.user]: user address(required)
        :returns dict: response from the exchange
        """
        user = self.safe_string(params, 'user')
        if user is None:
            raise ArgumentsRequired(self.id + ' dataPublicGetTotalValue() requires a user parameter')
        return await self.request('value', ['data', 'public'], 'GET', self.extend({'api_type': 'data'}, params))

    async def data_public_get_closed_positions(self, params={}):
        """
        fetches closed positions for a user from Data-API

        https://docs.polymarket.com/api-reference/core/get-closed-positions-for-a-user

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.user]: user address(required)
        :param str[] [params.market]: comma-separated list of condition IDs(mutually exclusive with eventId)
        :param int[] [params.eventId]: comma-separated list of event IDs(mutually exclusive with market)
        :param int [params.limit]: maximum number of results
        :param int [params.offset]: offset for pagination
        :param str [params.sortBy]: sort field
        :param str [params.sortDirection]: sort direction: ASC, DESC
        :returns dict: response from the exchange
        """
        user = self.safe_string(params, 'user')
        if user is None:
            raise ArgumentsRequired(self.id + ' dataPublicGetClosedPositions() requires a user parameter')
        return await self.request('closed-positions', ['data', 'public'], 'GET', self.extend({'api_type': 'data'}, params))

    async def data_public_get_traded(self, params={}):
        """
        fetches total markets a user has traded from Data-API

        https://docs.polymarket.com/api-reference/misc/get-total-markets-a-user-has-traded

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.user]: user address(required)
        :returns dict: response from the exchange
        """
        user = self.safe_string(params, 'user')
        if user is None:
            raise ArgumentsRequired(self.id + ' dataPublicGetTraded() requires a user parameter')
        return await self.request('traded', ['data', 'public'], 'GET', self.extend({'api_type': 'data'}, params))

    async def data_public_get_open_interest(self, params={}):
        """
        fetches open interest from Data-API

        https://docs.polymarket.com/api-reference/misc/get-open-interest

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str[] [params.market]: array of condition IDs(required)
        :returns dict: response from the exchange
        """
        market = self.safe_value(params, 'market')
        if market is None:
            raise ArgumentsRequired(self.id + ' dataPublicGetOpenInterest() requires a market parameter')
        # Convert market to array if it's a single string
        marketArray: List[str] = []
        if isinstance(market, list):
            marketArray = market
        elif isinstance(market, str):
            marketArray = [market]
        else:
            raise ArgumentsRequired(self.id + ' dataPublicGetOpenInterest() requires market to be a string or array of condition IDs')
        # API expects market in query params
        requestParams = self.extend({'market': marketArray}, self.omit(params, 'market'))
        return await self.request('oi', ['data', 'public'], 'GET', self.extend({'api_type': 'data'}, requestParams))

    async def data_public_get_live_volume(self, params={}):
        """
        fetches live volume for an event from Data-API

        https://docs.polymarket.com/api-reference/misc/get-live-volume-for-an-event

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.eventId]: event ID(required)
        :returns dict: response from the exchange
        """
        eventId = self.safe_integer(params, 'eventId')
        if eventId is None:
            raise ArgumentsRequired(self.id + ' dataPublicGetLiveVolume() requires an eventId parameter')
        return await self.request('live-volume', ['data', 'public'], 'GET', self.extend({'api_type': 'data'}, params))

    async def bridge_public_get_supported_assets(self, params={}):
        """
        fetches supported assets for bridging from Bridge API

        https://docs.polymarket.com/developers/misc-endpoints/bridge-supported-assets

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: response from the exchange
        """
        return await self.request('supported-assets', ['bridge', 'public'], 'GET', self.extend({'api_type': 'bridge'}, params))

    async def bridge_public_post_deposit(self, params={}):
        """
        creates deposit addresses for bridging assets to Polymarket

        https://docs.polymarket.com/developers/misc-endpoints/bridge-deposit

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.address]: Polymarket wallet address(required)
        :returns dict: response from the exchange
        """
        address = self.safe_string(params, 'address')
        if address is None:
            raise ArgumentsRequired(self.id + ' bridgePublicPostDeposit() requires an address parameter')
        body = self.json({'address': address})
        remainingParams = self.extend({'api_type': 'bridge'}, self.omit(params, 'address'))
        return await self.request('deposit', ['bridge', 'public'], 'POST', remainingParams, None, body)

    async def create_deposit_address(self, code: str, params={}):
        """
        create a deposit address for bridging assets to Polymarket

        https://docs.polymarket.com/developers/misc-endpoints/bridge-deposit

        :param str code: unified currency code
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.address]: Polymarket wallet address(required if not set in options)
        :returns dict: an `address structure <https://docs.ccxt.com/#/?id=address-structure>`
        """
        # Get address from params or use default from options
        address = self.safe_string(params, 'address')
        if address is None:
            # Try to get from options or raise error
            address = self.safe_string(self.options, 'address')
            if address is None:
                raise ArgumentsRequired(self.id + ' createDepositAddress() requires an address parameter or address in options')
        response = await self.bridge_public_post_deposit(self.extend({'address': address}, params))
        # Response format: {address: "...", depositAddresses: [{chainId, chainName, tokenAddress, tokenSymbol, depositAddress}, ...]}
        depositAddresses = self.safe_list(response, 'depositAddresses', [])
        # Find the deposit address for the requested currency code
        # For Polymarket, all deposits are converted to USDC.e, but we can filter by tokenSymbol
        currency = self.currency(code)
        depositAddress = None
        for i in range(0, len(depositAddresses)):
            addr = depositAddresses[i]
            tokenSymbol = self.safe_string(addr, 'tokenSymbol')
            if tokenSymbol and tokenSymbol.upper() == currency['code'].upper():
                depositAddress = self.safe_string(addr, 'depositAddress')
                break
        # If not found, return the first deposit address(default to USDC)
        if depositAddress is None and len(depositAddresses) > 0:
            depositAddress = self.safe_string(depositAddresses[0], 'depositAddress')
        return {
            'currency': code,
            'address': depositAddress,
            'tag': None,
            'info': response,
        }

    async def clob_public_get_orderbook_token_id(self, params={}):
        """
        fetches orderbook for a specific token ID from CLOB API
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: response from the exchange
        """
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            raise ArgumentsRequired(self.id + ' clobPublicGetOrderbookTokenId() requires a token_id parameter')
        # Note: CLOB API uses /book endpoint with token_id parameter, not /orderbook/{token_id}
        # See https://docs.polymarket.com/developers/CLOB/prices-books/get-book
        remainingParams = self.extend({'api_type': 'clob'}, params)
        return await self.request('book', ['clob', 'public'], 'GET', remainingParams)

    async def clob_public_post_books(self, params={}):
        """
        fetches order books for multiple token IDs from CLOB API

        https://docs.polymarket.com/api-reference/orderbook/get-multiple-order-books-summaries-by-request

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param Array [params.requests]: array of {token_id, limit?} objects(required)
        :returns dict: response from the exchange
        """
        requests = self.safe_value(params, 'requests')
        if requests is None or not isinstance(requests, list) or len(requests) == 0:
            raise ArgumentsRequired(self.id + ' clobPublicPostBooks() requires a requests parameter(array of {token_id, limit?} objects)')
        # Note: REST API endpoint format: POST /books with JSON body
        # See https://docs.polymarket.com/api-reference/orderbook/get-multiple-order-books-summaries-by-request
        # Request body: [{token_id: "..."}, {token_id: "...", limit: 10}, ...]
        # Response format: array of order book objects, each with asset_id, bids, asks, etc.
        body = self.json(requests)
        remainingParams = self.extend({'api_type': 'clob'}, self.omit(params, 'requests'))
        return await self.request('books', ['clob', 'public'], 'POST', remainingParams, None, body)

    async def clob_public_get_market_trades_events(self, params={}):
        """
        fetches market trade events for a specific condition ID from CLOB API

        https://docs.polymarket.com/developers/CLOB/clients/methods-public#getmarkettradesevents
        https://docs.polymarket.com/developers/CLOB/trades/trades-data-api

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.condition_id]: the condition ID(market ID) for the market
        :param int [params.limit]: the maximum number of trades to fetch(default: 100, max: 500)
        :param int [params.offset]: number of trades to skip before starting to return results(default: 0)
        :param boolean [params.takerOnly]: if True, returns only trades where the user is the taker(default: True)
        :param str [params.side]: filter by side: 'BUY' or 'SELL'
        :returns dict: response from the exchange
        """
        conditionId = self.safe_string(params, 'condition_id')
        if conditionId is None:
            raise ArgumentsRequired(self.id + ' clobPublicGetMarketTradesEvents() requires a condition_id parameter')
        # Note: CLOB REST API endpoint format: /trades?market={condition_id}
        # See https://docs.polymarket.com/developers/CLOB/trades/trades-data-api
        # The client SDK method getMarketTradesEvents() uses a different endpoint, but the REST API uses /trades
        request: dict = {
            'market': conditionId,
        }
        remainingParams = self.omit(params, 'condition_id')
        # Add optional parameters
        limit = self.safe_integer(remainingParams, 'limit')
        if limit is not None:
            request['limit'] = limit
        offset = self.safe_integer(remainingParams, 'offset')
        if offset is not None:
            request['offset'] = offset
        takerOnly = self.safe_bool(remainingParams, 'takerOnly')
        if takerOnly is not None:
            request['takerOnly'] = takerOnly
        side = self.safe_string(remainingParams, 'side')
        if side is not None:
            request['side'] = side
        # Add any other remaining params
        finalParams = self.extend({'api_type': 'clob'}, self.extend(request, self.omit(remainingParams, ['limit', 'offset', 'takerOnly', 'side'])))
        return await self.request('trades', ['clob', 'public'], 'GET', finalParams)

    async def clob_public_get_prices_history(self, params={}):
        """
        fetches historical price data for a token from CLOB API

        https://docs.polymarket.com/developers/CLOB/clients/methods-public#getpriceshistory

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.market]: the token ID(market parameter)
        :param str [params.interval]: the time interval: "max", "1w", "1d", "6h", "1h"
        :param int [params.startTs]: timestamp in seconds of the earliest candle to fetch
        :param int [params.endTs]: timestamp in seconds of the latest candle to fetch
        :param number [params.fidelity]: data fidelity/quality
        :returns dict: response from the exchange
        """
        market = self.safe_string(params, 'market')
        if market is None:
            raise ArgumentsRequired(self.id + ' clobPublicGetPricesHistory() requires a market(token_id) parameter')
        # Note: REST API endpoint format: /prices-history
        # See https://docs.polymarket.com/developers/CLOB/timeseries
        # Required: market
        # Time component(mutually exclusive): either(startTs and endTs) OR interval
        # Optional: fidelity
        # Response format: {"history": [{"t": timestamp, "p": price}, ...]}
        request: dict = {
            'market': market,
        }
        # Add time component - either startTs/endTs OR interval(mutually exclusive)
        startTs = self.safe_integer(params, 'startTs')
        endTs = self.safe_integer(params, 'endTs')
        interval = self.safe_string(params, 'interval')
        if startTs is not None or endTs is not None:
            # Use startTs/endTs when provided
            if startTs is not None:
                request['startTs'] = startTs
            if endTs is not None:
                request['endTs'] = endTs
        elif interval is not None:
            # Use interval when startTs/endTs are not provided
            request['interval'] = interval
        # Add optional fidelity parameter
        fidelity = self.safe_number(params, 'fidelity')
        if fidelity is not None:
            finalFidelity = fidelity
            # Polymarket enforces minimum fidelity per interval(e.g. interval=1m requires fidelity>=10)
            intervalForFidelity = self.safe_string(request, 'interval')
            if intervalForFidelity == '1m':
                finalFidelity = max(10, finalFidelity)
            request['fidelity'] = finalFidelity
        remainingParams = self.extend({'api_type': 'clob'}, self.extend(request, self.omit(params, ['market', 'startTs', 'endTs', 'fidelity', 'interval'])))
        return await self.request('prices-history', ['clob', 'public'], 'GET', remainingParams)

    async def clob_public_get_time(self, params={}):
        """
        fetches the current server timestamp from CLOB API

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py#L178

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: response from the exchange
        """
        # Based on get_server_time() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(TIME = "/time")
        return await self.request('time', ['clob', 'public'], 'GET', self.extend({'api_type': 'clob'}, params))

    async def clob_public_get_ok(self, params={}):
        """
        health check endpoint to confirm server is up

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py#L170

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: response from the exchange
        """
        # Based on get_ok() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py#L170
        return await self.request('', ['clob', 'public'], 'GET', self.extend({'api_type': 'clob'}, params))

    async def clob_public_get_fee_rate(self, params={}):
        """
        fetches the fee rate for a token from CLOB API

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID(required)
        :returns dict: response from the exchange
        """
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            raise ArgumentsRequired(self.id + ' clobPublicGetFeeRate() requires a token_id parameter')
        # Based on get_fee_rate() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(GET_FEE_RATE = "/fee-rate")
        remainingParams = self.extend({'api_type': 'clob'}, params)
        return await self.request('fee-rate', ['clob', 'public'], 'GET', remainingParams)

    async def clob_public_get_price(self, params={}):
        """
        fetches the market price for a specific token and side from CLOB API

        https://docs.polymarket.com/api-reference/pricing/get-market-price

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID(required)
        :param str [params.side]: the side: 'BUY' or 'SELL'(required)
        :returns dict: response from the exchange
        """
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            raise ArgumentsRequired(self.id + ' clobPublicGetPrice() requires a token_id parameter')
        side = self.safe_string(params, 'side')
        if side is None:
            raise ArgumentsRequired(self.id + ' clobPublicGetPrice() requires a side parameter(BUY or SELL)')
        # Note: REST API endpoint format: /price?token_id={token_id}&side={side}
        # See https://docs.polymarket.com/api-reference/pricing/get-market-price
        remainingParams = self.extend({'api_type': 'clob'}, params)
        return await self.request('price', ['clob', 'public'], 'GET', remainingParams)

    async def clob_public_get_prices(self, params={}):
        """
        fetches market prices for multiple tokens from CLOB API

        https://docs.polymarket.com/api-reference/pricing/get-multiple-market-prices

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str[] [params.token_ids]: array of token IDs to fetch prices for
        :param str [params.side]: the side: 'BUY' or 'SELL'(required if token_ids provided)
        :returns dict: response from the exchange
        """
        # Note: REST API endpoint format: /prices?token_id={token_id1,token_id2,...}
        # See https://docs.polymarket.com/api-reference/pricing/get-multiple-market-prices
        # Response format: {[token_id]: {BUY: "price", SELL: "price"}, ...}
        # The endpoint returns both BUY and SELL prices for each token_id
        remainingParams = self.extend({'api_type': 'clob'}, params)
        return await self.request('prices', ['clob', 'public'], 'GET', remainingParams)

    async def clob_public_post_prices(self, params={}):
        """
        fetches market prices for specified tokens and sides via POST request

        https://docs.polymarket.com/api-reference/pricing/get-multiple-market-prices-by-request

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param Array [params.requests]: array of {token_id, side} objects(required)
        :returns dict: response from the exchange
        """
        requests = self.safe_value(params, 'requests')
        if requests is None:
            raise ArgumentsRequired(self.id + ' clobPublicPostPrices() requires a requests parameter(array of {token_id, side} objects)')
        # Note: REST API endpoint format: POST /prices with JSON body
        # See https://docs.polymarket.com/api-reference/pricing/get-multiple-market-prices-by-request
        # Body format: [{"token_id": "1234567890", "side": "BUY"}, {"token_id": "1234567890", "side": "SELL"}]
        # Response format: {[token_id]: {BUY: "price", SELL: "price"}, ...}
        body = self.json(requests)
        remainingParams = self.extend({'api_type': 'clob'}, self.omit(params, 'requests'))
        return await self.request('prices', ['clob', 'public'], 'POST', remainingParams, None, body)

    async def clob_public_get_midpoint(self, params={}):
        """
        fetches the midpoint price for a specific token from CLOB API

        https://docs.polymarket.com/api-reference/pricing/get-midpoint-price

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID(required)
        :returns dict: response from the exchange
        """
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            raise ArgumentsRequired(self.id + ' clobPublicGetMidpoint() requires a token_id parameter')
        # Note: REST API endpoint format: /midpoint?token_id={token_id}
        # See https://docs.polymarket.com/api-reference/pricing/get-midpoint-price
        remainingParams = self.extend({'api_type': 'clob'}, params)
        return await self.request('midpoint', ['clob', 'public'], 'GET', remainingParams)

    async def clob_public_get_midpoints(self, params={}):
        """
        fetches midpoint prices for multiple tokens from CLOB API

        https://docs.polymarket.com/api-reference/pricing/get-midpoint-prices

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str[] [params.token_ids]: array of token IDs to fetch midpoints for(required)
        :returns dict: response from the exchange
        """
        tokenIds = self.safe_value(params, 'token_ids')
        if tokenIds is None or not isinstance(tokenIds, list) or len(tokenIds) == 0:
            raise ArgumentsRequired(self.id + ' clobPublicGetMidpoints() requires a token_ids parameter(array of token IDs)')
        # Note: REST API endpoint format: POST /midpoints with JSON body
        # See https://docs.polymarket.com/api-reference/pricing/get-midpoint-prices
        # Request body: [{token_id: "..."}, {token_id: "..."}, ...]
        # Response format: {[token_id]: "midpoint", ...}
        body: List[Any] = []
        for i in range(0, len(tokenIds)):
            body.append({'token_id': tokenIds[i]})
        remainingParams = self.extend({'api_type': 'clob'}, self.omit(params, 'token_ids'))
        return await self.request('midpoints', ['clob', 'public'], 'POST', remainingParams, None, self.json(body))

    async def clob_public_get_spread(self, params={}):
        """
        fetches the bid-ask spread for a specific token from CLOB API

        https://docs.polymarket.com/api-reference/spreads/get-bid-ask-spread

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID(required)
        :returns dict: response from the exchange
        """
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            raise ArgumentsRequired(self.id + ' clobPublicGetSpread() requires a token_id parameter')
        # Note: REST API endpoint format: /spread?token_id={token_id}
        # See https://docs.polymarket.com/api-reference/spreads/get-bid-ask-spread
        remainingParams = self.extend({'api_type': 'clob'}, params)
        return await self.request('spread', ['clob', 'public'], 'GET', remainingParams)

    async def clob_public_get_last_trade_price(self, params={}):
        """
        fetches the last trade price for a specific token from CLOB API

        https://docs.polymarket.com/api-reference/trades/get-last-trade-price

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID(required)
        :returns dict: response from the exchange
        """
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            raise ArgumentsRequired(self.id + ' clobPublicGetLastTradePrice() requires a token_id parameter')
        # Note: REST API endpoint format: /last-trade-price?token_id={token_id}
        # See https://docs.polymarket.com/api-reference/trades/get-last-trade-price
        remainingParams = self.extend({'api_type': 'clob'}, params)
        return await self.request('last-trade-price', ['clob', 'public'], 'GET', remainingParams)

    async def clob_public_get_last_trades_prices(self, params={}):
        """
        fetches last trade prices for multiple tokens from CLOB API

        https://docs.polymarket.com/api-reference/trades/get-last-trades-prices

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str[] [params.token_ids]: array of token IDs to fetch last trade prices for(required)
        :returns dict: response from the exchange
        """
        tokenIds = self.safe_value(params, 'token_ids')
        if tokenIds is None or not isinstance(tokenIds, list) or len(tokenIds) == 0:
            raise ArgumentsRequired(self.id + ' clobPublicGetLastTradesPrices() requires a token_ids parameter(array of token IDs)')
        # Note: REST API endpoint format: POST /last-trades-prices with JSON body
        # See https://docs.polymarket.com/api-reference/trades/get-last-trades-prices
        # Request body: [{token_id: "..."}, {token_id: "..."}, ...]
        # Response format: {[token_id]: "price", ...}
        body: List[Any] = []
        for i in range(0, len(tokenIds)):
            body.append({'token_id': tokenIds[i]})
        remainingParams = self.extend({'api_type': 'clob'}, self.omit(params, 'token_ids'))
        return await self.request('last-trades-prices', ['clob', 'public'], 'POST', remainingParams, None, self.json(body))

    async def clob_public_get_trades(self, params={}):
        """
        fetches trades for a specific market from CLOB API

        https://docs.polymarket.com/developers/CLOB/clients/methods-public#trades

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.market]: the token ID or condition ID(required)
        :param int [params.limit]: maximum number of trades to return(default: 100, max: 500)
        :param str [params.side]: filter by side: 'BUY' or 'SELL'
        :param int [params.start_timestamp]: start timestamp in seconds
        :param int [params.end_timestamp]: end timestamp in seconds
        :returns dict: response from the exchange
        """
        market = self.safe_string(params, 'market')
        if market is None:
            raise ArgumentsRequired(self.id + ' clobPublicGetTrades() requires a market(token_id or condition_id) parameter')
        # Note: REST API endpoint format: /trades?market={token_id}
        # See https://docs.polymarket.com/developers/CLOB/clients/methods-public#trades
        request: dict = {
            'market': market,
        }
        limit = self.safe_integer(params, 'limit')
        if limit is not None:
            request['limit'] = min(limit, 500)  # Cap at 500
        side = self.safe_string(params, 'side')
        if side is not None:
            request['side'] = side
        startTimestamp = self.safe_integer(params, 'start_timestamp')
        if startTimestamp is not None:
            request['start_timestamp'] = startTimestamp
        endTimestamp = self.safe_integer(params, 'end_timestamp')
        if endTimestamp is not None:
            request['end_timestamp'] = endTimestamp
        remainingParams = self.extend({'api_type': 'clob'}, self.extend(request, self.omit(params, ['market', 'limit', 'side', 'start_timestamp', 'end_timestamp'])))
        return await self.request('trades', ['clob', 'public'], 'GET', remainingParams)

    async def clob_public_get_tick_size(self, params={}):
        """
        fetches the tick size for a token from CLOB API

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID(required)
        :returns dict: response from the exchange
        """
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            raise ArgumentsRequired(self.id + ' clobPublicGetTickSize() requires a token_id parameter')
        # Based on get_tick_size() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(GET_TICK_SIZE = "/tick-size")
        remainingParams = self.extend({'api_type': 'clob'}, params)
        return await self.request('tick-size', ['clob', 'public'], 'GET', remainingParams)

    async def clob_public_get_neg_risk(self, params={}):
        """
        fetches the negative risk flag for a token from CLOB API

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: the token ID(required)
        :returns dict: response from the exchange
        """
        tokenId = self.safe_string(params, 'token_id')
        if tokenId is None:
            raise ArgumentsRequired(self.id + ' clobPublicGetNegRisk() requires a token_id parameter')
        # Based on get_neg_risk() from py-clob-client
        # See https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(GET_NEG_RISK = "/neg-risk")
        remainingParams = self.extend({'api_type': 'clob'}, params)
        return await self.request('neg-risk', ['clob', 'public'], 'GET', remainingParams)

    async def clob_public_post_spreads(self, params={}):
        """
        fetches bid-ask spreads for multiple tokens from CLOB API

        https://docs.polymarket.com/api-reference/spreads/get-bid-ask-spreads

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str[] [params.token_ids]: array of token IDs to fetch spreads for(required)
        :returns dict: response from the exchange
        """
        tokenIds = self.safe_value(params, 'token_ids')
        if tokenIds is None or not isinstance(tokenIds, list) or len(tokenIds) == 0:
            raise ArgumentsRequired(self.id + ' clobPublicPostSpreads() requires a token_ids parameter(array of token IDs)')
        # Note: REST API endpoint format: POST /spreads
        # See https://docs.polymarket.com/api-reference/spreads/get-bid-ask-spreads
        # Request body: [{token_id: "..."}, {token_id: "..."}, ...]
        # Response format: {[token_id]: "spread", ...}
        body: List[Any] = []
        for i in range(0, len(tokenIds)):
            body.append({'token_id': tokenIds[i]})
        remainingParams = self.extend({'api_type': 'clob'}, self.omit(params, 'token_ids'))
        return await self.request('spreads', ['clob', 'public'], 'POST', remainingParams, None, self.json(body))

    async def clob_private_get_order(self, params={}):
        """
        fetches a specific order by order ID

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(GET_ORDER = "/data/order/")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.order_id]: the order ID(required)
        :returns dict: response from the exchange
        """
        orderId = self.safe_string(params, 'order_id')
        if orderId is None:
            raise ArgumentsRequired(self.id + ' clobPrivateGetOrder() requires an order_id parameter')
        path = 'data/order/' + self.encode_uri_component(orderId)
        remainingParams = self.extend({'api_type': 'clob'}, self.omit(params, 'order_id'))
        return await self.request(path, ['clob', 'private'], 'GET', remainingParams)

    async def clob_private_get_orders(self, params={}):
        """
        fetches orders for the authenticated user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(ORDERS = "/data/orders")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: filter orders by token ID
        :param str [params.status]: filter orders by status(OPEN, FILLED, CANCELLED, etc.)
        :returns dict: response from the exchange
        """
        return await self.request('data/orders', ['clob', 'private'], 'GET', self.extend({'api_type': 'clob'}, params))

    async def clob_private_post_order(self, params={}):
        """
        creates a new order

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(POST_ORDER = "/order")
        https://docs.polymarket.com/developers/CLOB/orders/create-order#request-payload-parameters

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param dict [params.order]: order object(required)
        :param str [params.owner]: api key of order owner(required)
        :param str [params.orderType]: order type: "FOK", "GTC", "GTD"(required)
        :returns dict: response from the exchange
        """
        # Build request payload according to API specification
        # See https://docs.polymarket.com/developers/CLOB/orders/create-order#request-payload-parameters
        order = self.safe_value(params, 'order')
        if order is None:
            raise ArgumentsRequired(self.id + ' clobPrivatePostOrder() requires an order parameter')
        owner = self.safe_string(params, 'owner')
        if owner is None:
            raise ArgumentsRequired(self.id + ' clobPrivatePostOrder() requires an owner parameter(API key)')
        orderType = self.safe_string(params, 'orderType')
        if orderType is None:
            raise ArgumentsRequired(self.id + ' clobPrivatePostOrder() requires an orderType parameter')
        # Build the complete request payload with top-level fields
        requestPayload: dict = {
            'order': order,
            'owner': owner,
            'orderType': orderType,
        }
        # Add optional parameters if provided
        clientOrderId = self.safe_string(params, 'clientOrderId')
        if clientOrderId is not None:
            requestPayload['clientOrderId'] = clientOrderId
        postOnly = self.safe_bool(params, 'postOnly')
        if postOnly is not None:
            requestPayload['postOnly'] = postOnly
        # Send the complete request payload body
        body = self.json(requestPayload)
        remainingParams = self.extend({'api_type': 'clob'}, self.omit(params, ['order', 'owner', 'orderType', 'clientOrderId', 'postOnly']))
        return await self.request('order', ['clob', 'private'], 'POST', remainingParams, None, body)

    async def clob_private_post_orders(self, params={}):
        """
        creates multiple orders in a batch

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(POST_ORDERS = "/orders")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param Array [params.orders]: array of order objects(required)
        :returns dict: response from the exchange
        """
        orders = self.safe_value(params, 'orders')
        if orders is None or not isinstance(orders, list):
            raise ArgumentsRequired(self.id + ' clobPrivatePostOrders() requires an orders parameter(array of order objects)')
        body = self.json(orders)
        remainingParams = self.extend({'api_type': 'clob'}, self.omit(params, 'orders'))
        return await self.request('orders', ['clob', 'private'], 'POST', remainingParams, None, body)

    async def clob_private_delete_order(self, params={}):
        """
        cancels an order

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(CANCEL = "/order")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.order_id]: the order ID to cancel(required)
        :returns dict: response from the exchange
        """
        orderId = self.safe_string(params, 'order_id')
        if orderId is None:
            raise ArgumentsRequired(self.id + ' clobPrivateDeleteOrder() requires an order_id parameter')
        request: dict = {
            'orderID': orderId,
        }
        remainingParams = self.extend({'api_type': 'clob'}, self.omit(params, 'order_id'))
        body = self.json(request)
        return await self.request('order', ['clob', 'private'], 'DELETE', remainingParams, None, body)

    async def clob_private_delete_orders(self, params={}):
        """
        cancels multiple orders

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(CANCEL_ORDERS = "/orders")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str[] [params.order_ids]: array of order IDs to cancel(required)
        :returns dict: response from the exchange
        """
        orderIds = self.safe_value(params, 'order_ids')
        if orderIds is None or not isinstance(orderIds, list):
            raise ArgumentsRequired(self.id + ' clobPrivateDeleteOrders() requires an order_ids parameter(array of order IDs)')
        body = self.json(orderIds)
        remainingParams = self.extend({'api_type': 'clob'}, self.omit(params, 'order_ids'))
        return await self.request('orders', ['clob', 'private'], 'DELETE', remainingParams, None, body)

    async def clob_private_delete_cancel_all(self, params={}):
        """
        cancels all open orders

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(CANCEL_ALL = "/cancel-all")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: optional token ID to cancel all orders for a specific market
        :returns dict: response from the exchange
        """
        body = self.json(params)
        return await self.request('cancel-all', ['clob', 'private'], 'DELETE', {'api_type': 'clob'}, None, body)

    async def clob_private_delete_cancel_market_orders(self, params={}):
        """
        cancels all orders from a market

        https://docs.polymarket.com/developers/CLOB/orders/cancel-market-orders

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.market]: condition id of the market
        :param str [params.asset_id]: id of the asset/token
        :returns dict: response from the exchange
        """
        request: dict = {}
        market = self.safe_string(params, 'market')
        if market is not None:
            request['market'] = market
        assetId = self.safe_string(params, 'asset_id')
        if assetId is not None:
            request['asset_id'] = assetId
        remainingParams = self.extend({'api_type': 'clob'}, self.omit(params, ['market', 'asset_id']))
        body = self.json(request)
        return await self.request('cancel-market-orders', ['clob', 'private'], 'DELETE', remainingParams, None, body)

    async def clob_private_get_trades(self, params={}):
        """
        fetches trade history for the authenticated user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py(get_trades method)

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: filter trades by token ID
        :param int [params.start_timestamp]: start timestamp in seconds
        :param str [params.next_cursor]: pagination cursor
        :returns dict: response from the exchange
        """
        # NOTE: the authenticated L2 endpoint is `/trades`(without the public `/data/` prefix).
        # Using the public path would return all market trades instead of the caller's own fills.
        return await self.request('trades', ['clob', 'private'], 'GET', self.extend({'api_type': 'clob'}, params))

    async def clob_private_get_builder_trades(self, params={}):
        """
        fetches trades originated by the builder

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(GET_BUILDER_TRADES = "/builder-trades")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.token_id]: filter trades by token ID
        :param int [params.start_timestamp]: start timestamp in seconds
        :param str [params.next_cursor]: pagination cursor
        :returns dict: response from the exchange
        """
        return await self.request('builder-trades', ['clob', 'private'], 'GET', self.extend({'api_type': 'clob'}, params))

    async def clob_private_get_notifications(self, params={}):
        """
        fetches notifications for the authenticated user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(GET_NOTIFICATIONS = "/notifications")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: response from the exchange
        """
        return await self.request('notifications', ['clob', 'private'], 'GET', self.extend({'api_type': 'clob'}, params))

    async def clob_private_delete_notifications(self, params={}):
        """
        drops notifications for the authenticated user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(DROP_NOTIFICATIONS = "/notifications")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.notification_id]: specific notification ID to drop
        :returns dict: response from the exchange
        """
        return await self.request('notifications', ['clob', 'private'], 'DELETE', self.extend({'api_type': 'clob'}, params))

    async def clob_private_get_balance_allowance(self, params={}):
        """
        fetches balance and allowance for the authenticated user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(GET_BALANCE_ALLOWANCE = "/balance-allowance")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.signature_type]: signature type(default: from options.signatureType or options.signatureTypes.EOA).
        :returns dict: response from the exchange
        """
        return await self.request('balance-allowance', ['clob', 'private'], 'GET', self.extend({'api_type': 'clob'}, params))

    async def clob_private_put_balance_allowance(self, params={}):
        """
        updates balance and allowance for the authenticated user

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(UPDATE_BALANCE_ALLOWANCE = "/balance-allowance")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.signature_type]: signature type(default: from options.signatureType or options.signatureTypes.EOA).
        :returns dict: response from the exchange
        """
        body = self.json(params)
        return await self.request('balance-allowance', ['clob', 'private'], 'PUT', {'api_type': 'clob'}, None, body)

    async def clob_private_get_is_order_scoring(self, params={}):
        """
        checks if an order is currently scoring

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(IS_ORDER_SCORING = "/is-order-scoring")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.order_id]: the order ID(required)
        :param str [params.token_id]: the token ID(required)
        :param str [params.side]: the side: 'BUY' or 'SELL'(required)
        :param str [params.price]: the price(required)
        :param str [params.size]: the size(required)
        :returns dict: response from the exchange
        """
        # GET /order-scoring?order_id=...
        return await self.request('order-scoring', ['clob', 'private'], 'GET', self.extend({'api_type': 'clob'}, params))

    async def clob_private_post_are_orders_scoring(self, params={}):
        """
        checks if multiple orders are currently scoring

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/endpoints.py(ARE_ORDERS_SCORING = "/are-orders-scoring")

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str[] [params.orderIds]: array of order IDs to check(required)
        :returns dict: response from the exchange
        """
        orderIds = self.safe_value_2(params, 'orderIds', 'order_ids')
        if orderIds is None or not isinstance(orderIds, list):
            raise ArgumentsRequired(self.id + ' clobPrivatePostAreOrdersScoring() requires an orderIds parameter(array of order IDs)')
        body = self.json({'orderIds': orderIds})
        remainingParams = self.extend({'api_type': 'clob'}, self.omit(params, ['orderIds', 'order_ids']))
        # POST /orders-scoring with JSON body {orderIds: [...]}
        return await self.request('orders-scoring', ['clob', 'private'], 'POST', remainingParams, None, body)

    def get_main_wallet_address(self):
        """
        gets main wallet address(walletAddress or options.funder)
        :returns str: main wallet address
        """
        if self.walletAddress is not None and self.walletAddress != '':
            return self.walletAddress
        funder = self.safe_string(self.options, 'funder')
        if funder is not None and funder != '':
            return funder
        raise ArgumentsRequired(self.id + ' getMainWalletAddress() requires a wallet address. Set `walletAddress` or `options.funder`.')

    def get_proxy_wallet_address(self):
        """
        gets proxy wallet address for Data-API endpoints(falls back to main wallet if not set)
        :returns str: proxy wallet address
        """
        if self.uid is not None and self.uid != '':
            return self.uid
        proxyWallet = self.safe_string(self.options, 'proxyWallet')
        if proxyWallet is not None and proxyWallet != '':
            return proxyWallet
        # Fall back to main wallet if proxyWallet is not set
        return self.get_main_wallet_address()

    def get_builder_wallet_address(self):
        """
        gets builder wallet address(falls back to main wallet if not set)
        :returns str: builder wallet address
        """
        builderWallet = self.safe_string(self.options, 'builderWallet')
        if builderWallet is not None and builderWallet != '':
            return builderWallet
        # Fall back to main wallet if builderWallet is not set
        return self.get_main_wallet_address()

    async def get_user_total_value(self, userAddress: str = None) -> dict:
        """
        fetches total value of a user's positions from Data-API

        https://docs.polymarket.com/api-reference/core/get-total-value-of-a-users-positions

        :param str [userAddress]: user wallet address(defaults to getProxyWalletAddress())
        :returns dict: object with 'value'(number) and 'response'(raw API response)
        """
        address: str = None
        if userAddress is not None:
            # Use provided address directly(public endpoint, no wallet setup needed)
            address = userAddress
        else:
            # Try to get proxy wallet address, but handle case where wallet is not configured
            # This allows public calls without requiring wallet setup
            try:
                address = self.get_proxy_wallet_address()
            except Exception as e:
                # If wallet is not configured, require userAddress parameter for public calls
                raise ArgumentsRequired(self.id + ' getUserTotalValue() requires a userAddress parameter when wallet is not configured. This is a public endpoint that can query any user address.')
        # Fetch total value from Data-API
        valueResponse = await self.data_public_get_total_value({'user': address})
        # Response format: [{"user": "0x...", "value": 123}]
        valueData = valueResponse
        if isinstance(valueResponse, list):
            if len(valueResponse) > 0:
                valueData = valueResponse[0]
            else:
                valueData = {}
        totalValue = self.safe_number(valueData, 'value', 0)
        return {
            'value': totalValue,
            'response': valueResponse,
        }

    async def get_user_positions(self, userAddress: str = None, params={}) -> dict:
        """
        fetches current positions for a user from Data-API(defaults to proxy wallet)

        https://docs.polymarket.com/api-reference/core/get-current-positions-for-a-user

        :param str [userAddress]: user wallet address(defaults to getProxyWalletAddress())
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: response from the exchange
        """
        # TODO add pagination, sort, limit etc https://docs.polymarket.com/api-reference/core/get-current-positions-for-a-user
        address: str = None
        if userAddress is not None:
            # Use provided address directly(public endpoint, no wallet setup needed)
            address = userAddress
        else:
            # Try to get proxy wallet address, but handle case where wallet is not configured
            # This allows public calls without requiring wallet setup
            try:
                address = self.get_proxy_wallet_address()
            except Exception as e:
                # If wallet is not configured, require userAddress parameter for public calls
                raise ArgumentsRequired(self.id + ' getUserPositions() requires a userAddress parameter when wallet is not configured. This is a public endpoint that can query any user address.')
        return await self.data_public_get_positions(self.extend({'user': address}, params))

    async def get_user_activity(self, userAddress: str = None, params={}) -> dict:
        """
        fetches user activity from Data-API(defaults to proxy wallet)

        https://docs.polymarket.com/api-reference/core/get-user-activity

        :param str [userAddress]: user wallet address(defaults to getProxyWalletAddress())
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: response from the exchange
        """
        address: str = None
        if userAddress is not None:
            # Use provided address directly(public endpoint, no wallet setup needed)
            address = userAddress
        else:
            # Try to get proxy wallet address, but handle case where wallet is not configured
            # This allows public calls without requiring wallet setup
            try:
                address = self.get_proxy_wallet_address()
            except Exception as e:
                # If wallet is not configured, require userAddress parameter for public calls
                raise ArgumentsRequired(self.id + ' getUserActivity() requires a userAddress parameter when wallet is not configured. This is a public endpoint that can query any user address.')
        request: dict = {
            'user': address,
            'limit': self.safe_integer(params, 'limit', 100),
            'offset': self.safe_integer(params, 'offset', 0),
            'sortBy': self.safe_string(params, 'sortBy', 'TIMESTAMP'),
            'sortDirection': self.safe_string(params, 'sortDirection', 'DESC'),
        }
        return await self.data_public_get_activity(self.extend(request, self.omit(params, ['user'])))

    def parse_user_activity(self, activity: dict, market: Market = None) -> dict:
        """
        parse a raw user activity record into a trade-like structure consumable by parseTrades
        :param dict activity: raw activity payload from Data-API
        :param dict [market]: market structure, when known
        :returns dict|None: normalized activity(only for TRADE records) or None
        """
        activityType = self.safe_string(activity, 'type')
        if activityType != 'TRADE':
            return None
        rawTs = self.safe_integer(activity, 'timestamp')
        isoTimestamp = self.safe_string(activity, 'timestamp')
        if rawTs is not None:
            tsMs = rawTs * 1000 if (rawTs < 1000000000000) else rawTs
            isoTimestamp = self.iso8601(tsMs)
        symbol = market['symbol'] if (market is not None) else self.safe_string(activity, 'condition_id')
        return self.extend(activity, {
            'timestamp': isoTimestamp,
            'transactionHash': self.safe_string(activity, 'transactionHash'),
            'symbol': symbol,
            'asset': self.safe_string(activity, 'asset'),
            'price': self.safe_number(activity, 'price'),
            'size': self.safe_number(activity, 'size'),
            'side': self.safe_string(activity, 'side'),
        })

    def format_address(self, address: str = None):
        if address is None:
            return None
        if address.startswith('0x'):
            return address.replace('0x', '')
        return address

    def normalize_address(self, address: str) -> str:
        normalized = str(address).strip()
        if not normalized.startswith('0x'):
            normalized = '0x' + normalized
        return normalized.lower()

    def hash_message(self, message: str) -> str:
        binaryMessage = self.encode(message)
        binaryMessageLength = self.binary_length(binaryMessage)
        x19 = self.base16_to_binary('19')
        newline = self.base16_to_binary('0a')
        prefix = self.binary_concat(x19, self.encode('Ethereum Signed Message:'), newline, self.encode(self.number_to_string(binaryMessageLength)))
        return '0x' + self.hash(self.binary_concat(prefix, binaryMessage), 'keccak', 'hex')

    def get_contract_config(self, chainID: float) -> dict:
        contracts = self.safe_value(self.options, 'contracts', {})
        chainIdStr = str(chainID)
        contractConfig = self.safe_value(contracts, chainIdStr)
        if contractConfig is None:
            raise ExchangeError(self.id + ' getContractConfig() invalid network chainId: ' + chainIdStr)
        return contractConfig

    def sign_message(self, message: str, privateKey: str) -> str:
        hash = self.hash_message(message)
        return self.sign_hash(hash, privateKey)

    def sign_hash(self, hash: str, privateKey: str):
        signature = self.ecdsa(hash[-64:], privateKey[-64:], 'secp256k1', None)
        r = signature['r']
        s = signature['s']
        v = self.int_to_base16(self.sum(27, signature['v']))
        # Convert to lowercase hex(Ethereum standard)
        finalSignature = ('0x' + r.rjust(64, '0') + s.rjust(64, '0') + v.rjust(2, '0')).lower()
        return finalSignature

    def sign_typed_data(self, domain: dict, types: dict, value: dict) -> str:
        # This returns binary data: 0x1901 or hashDomain(domain) or hashStruct(primaryType, types, value)
        encoded = self.eth_encode_structured_data(domain, types, value)
        # Hash the encoded binary data with keccak256
        hash = '0x' + self.hash(encoded, 'keccak', 'hex')
        # Sign the hash using signHash
        signature = self.sign_hash(hash, self.privateKey)
        return signature

    def create_level1_headers(self, walletAddress: str, nonce: float = None) -> dict:
        if walletAddress is None or walletAddress == '':
            raise ArgumentsRequired(self.id + ' createLevel1Headers() requires a valid walletAddress')
        normalizedAddress = self.normalize_address(walletAddress)
        chainId = self.safe_integer(self.options, 'chainId')
        timestampSeconds = int(math.floor(self.milliseconds()) / 1000)
        timestamp = str(timestampSeconds)
        nonceValue = 0
        if nonce is not None:
            nonceValue = nonce
        clobDomainName = self.safe_string(self.options, 'clobDomainName')
        clobVersion = self.safe_string(self.options, 'clobVersion')
        msgToSign = self.safe_string(self.options, 'msgToSign')
        domain = {
            'name': clobDomainName,
            'version': clobVersion,
            'chainId': chainId,
        }
        # https://github.com/Polymarket/clob-client/blob/b75aec68be17190215b7230372fbedfe85de20ef/src/signing/eip712.ts#L28
        types = {
            'ClobAuth': [
                {'name': 'address', 'type': 'address'},
                {'name': 'timestamp', 'type': 'string'},
                {'name': 'nonce', 'type': 'uint256'},
                {'name': 'message', 'type': 'string'},
            ],
        }
        message = {
            'address': normalizedAddress,
            'timestamp': timestamp,
            'nonce': nonceValue,
            'message': msgToSign,
        }
        signature = self.sign_typed_data(domain, types, message)
        headers = {
            'POLY_ADDRESS': normalizedAddress,
            'POLY_TIMESTAMP': timestamp,
            'POLY_NONCE': str(nonceValue),
            'POLY_SIGNATURE': signature,
        }
        return headers

    def get_clob_base_url(self, params={}) -> str:
        """
        Gets the CLOB API base URL(handles sandbox mode and custom hosts)
        :param dict [params]: extra parameters
        :returns str: base URL for CLOB API
        """
        apiType = self.safe_string(params, 'api_type', 'clob')
        baseUrl = self.urls['api'][apiType]
        # Check for sandbox mode
        if self.isSandboxModeEnabled and self.urls['test'] and self.urls['test'][apiType]:
            baseUrl = self.urls['test'][apiType]
        if apiType == 'clob':
            customHost = self.safe_string(self.options, 'clobHost')
            if customHost is not None:
                baseUrl = customHost
        return baseUrl

    def parse_api_credentials(self, response: Any) -> dict:
        """
        Parses API credentials from API response and caches them
        :param dict response: API response
        :returns dict} API credentials {apiKey, secret, passphrase:
        """
        apiKey = self.safe_string(response, 'apiKey') or self.safe_string(response, 'api_key')
        secret = self.safe_string(response, 'secret')
        passphrase = self.safe_string(response, 'passphrase')
        if not apiKey or not secret or not passphrase:
            raise ExchangeError(self.id + ' parseApiCredentials() failed to parse credentials. Response: ' + self.json(response))
        credentials = {
            'apiKey': apiKey,
            'secret': secret,
            'passphrase': passphrase,
        }
        # Cache credentials in options
        self.options['apiCredentials'] = credentials
        # Also set them properties for use in sign() method
        self.apiKey = apiKey
        self.secret = secret
        self.password = passphrase
        return credentials

    async def create_api_key(self, params={}) -> dict:
        """
        Creates a new CLOB API key for the given address

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        https://docs.polymarket.com/developers/CLOB/authentication

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param number [params.nonce]: optional nonce/timestamp
        :returns dict} API credentials {apiKey, secret, passphrase:
 @note Uses manual URL building instead of self.request() because self endpoint requires L1 authentication
 (POLY_ADDRESS, POLY_SIGNATURE headers) rather than the standard L2 authentication used by self.request()
        """
        if self.privateKey is None:
            raise ArgumentsRequired(self.id + ' create_api_key() requires a privateKey')
        # Validate privateKey format(should be hex string with 0x prefix, 66 chars total)
        if not self.privateKey.startswith('0x') or len(self.privateKey) != 66:
            raise ArgumentsRequired(self.id + ' create_api_key() requires a valid privateKey(0x-prefixed hex string, 66 characters)')
        walletAddress = self.get_main_wallet_address()
        # Validate walletAddress format(should be hex string with 0x prefix, 42 chars total)
        if not walletAddress.startswith('0x') or len(walletAddress) != 42:
            raise ArgumentsRequired(self.id + ' create_api_key() requires a valid walletAddress(0x-prefixed hex string, 42 characters). Got: ' + walletAddress)
        baseUrl = self.get_clob_base_url(params)
        nonce = self.safe_integer(params, 'nonce')
        headers = self.create_level1_headers(walletAddress, nonce)
        url = baseUrl + '/auth/api-key'
        # POST /auth/api-key(creates new API credentials with L1 authentication)
        response = await self.fetch(url, 'POST', headers, None)
        return self.parse_api_credentials(response)

    async def derive_api_key(self, params={}) -> dict:
        """
        Derives an already existing CLOB API key for the given address and nonce

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py
        https://docs.polymarket.com/developers/CLOB/authentication

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param number [params.nonce]: optional nonce/timestamp
        :returns dict} API credentials {apiKey, secret, passphrase:
 @note Uses manual URL building instead of self.request() because self endpoint requires L1 authentication
 (POLY_ADDRESS, POLY_SIGNATURE headers) rather than the standard L2 authentication used by self.request()
        """
        if self.privateKey is None:
            raise ArgumentsRequired(self.id + ' derive_api_key() requires a privateKey')
        walletAddress = self.get_main_wallet_address()
        baseUrl = self.get_clob_base_url(params)
        nonce = self.safe_integer(params, 'nonce')
        headers = self.create_level1_headers(walletAddress, nonce)
        url = baseUrl + '/auth/derive-api-key'
        # GET /auth/derive-api-key(derives existing API credentials with L1 authentication)
        response = await self.fetch(url, 'GET', headers, None)
        return self.parse_api_credentials(response)

    async def create_or_derive_api_creds(self, params={}) -> dict:
        """
        Creates API creds if not already created for nonce, otherwise derives them

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param number [params.nonce]: optional nonce/timestamp
        :returns dict} API credentials {apiKey, secret, passphrase:
        """
        # Check if credentials are already cached
        cachedCreds = self.safe_dict(self.options, 'apiCredentials')
        if cachedCreds is not None:
            return cachedCreds
        # Try create_api_key first, then derive_api_key if create fails
        # Based on py-clob-client client.py: create_or_derive_api_creds()
        try:
            return await self.create_api_key(params)
        except Exception as e:
            # If create fails(e.g., key already exists), try to derive it
            return await self.derive_api_key(params)

    def set_api_creds(self, credentials: dict):
        """
        Sets API credentials(alias for caching credentials)

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/client.py

        :param dict credentials: API credentials {apiKey, secret, passphrase}
        """
        self.options['apiCredentials'] = credentials
        self.apiKey = self.safe_string(credentials, 'apiKey')
        self.secret = self.safe_string(credentials, 'secret')
        self.password = self.safe_string(credentials, 'passphrase')

    def get_api_base_url(self, params={}) -> str:
        """
        Gets the API base URL for the specified API type(handles sandbox mode and custom hosts)
        :param dict [params]: extra parameters
        :param str [params.api_type]: API type('clob', 'gamma', 'data', etc.)
        :returns str: base URL for the API
        """
        apiType = self.safe_string(params, 'api_type', 'clob')
        # Ensure urls.api exists
        if self.urls is None or self.urls['api'] is None:
            raise ExchangeError(self.id + ' getApiBaseUrl() failed: urls.api is not initialized. Make sure exchange is properly initialized.')
        # Direct access to nested object property
        baseUrl = self.urls['api'][apiType]
        # Check for sandbox mode
        if self.isSandboxModeEnabled and self.urls['test'] and self.urls['test'][apiType]:
            baseUrl = self.urls['test'][apiType]
        # Allow custom CLOB host override
        if apiType == 'clob':
            customHost = self.safe_string(self.options, 'clobHost')
            if customHost is not None:
                baseUrl = customHost
        # Ensure we have a valid base URL
        if baseUrl is None:
            apiUrls = self.urls['api'] or {}
            availableTypesList = list(apiUrls.keys())
            availableTypes = ''
            if len(availableTypesList) > 0:
                availableTypes = ', '.join(availableTypesList)
            raise ExchangeError(self.id + ' getApiBaseUrl() failed: API type "' + apiType + '" not found in urls.api. Available types: ' + availableTypes)
        return baseUrl

    def build_default_headers(self, method: str, existingHeaders: dict = None) -> dict:
        """
        Builds default HTTP headers based on py-clob-client helpers.py

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/http_helpers/helpers.py

        :param str method: HTTP method('GET', 'POST', etc.)
        :param dict [existingHeaders]: existing headers to self.extend
        :returns dict: headers dictionary
        """
        if existingHeaders is None:
            existingHeaders = {}
        headers = self.extend({
            'User-Agent': 'ccxt',
            'Accept': '*/*',
            'Connection': 'keep-alive',
            'Content-Type': 'application/json',
        }, existingHeaders)
        # Add Accept-Encoding for GET requests(as per py-clob-client)
        if method == 'GET':
            headers['Accept-Encoding'] = 'gzip'
        return headers

    def build_public_request(self, baseUrl: str, pathWithParams: str, method: str, queryParams: dict, body: str = None, headers: dict = None) -> dict:
        """
        Builds a public(unauthenticated) request
        :param str baseUrl: API base URL
        :param str pathWithParams: path with parameters
        :param str method: HTTP method
        :param dict queryParams: query parameters
        :param str [body]: request body
        :param dict [headers]: request headers
        :returns dict: request object with url, method, body, and headers
        """
        headers = self.build_default_headers(method, headers)
        url = baseUrl + '/' + pathWithParams
        if method == 'GET':
            if queryParams:
                url += '?' + self.urlencode(queryParams)
        else:
            # For POST requests, body should already be set by the calling method
            if body is None and queryParams:
                body = self.json(queryParams)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    async def ensure_api_credentials(self, params={}) -> dict:
        """
        Ensures API credentials are generated(lazy generation, similar to dYdX's retrieveCredentials)
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict} API credentials {apiKey, secret, passphrase:
        """
        # Check if credentials are already cached
        cachedCreds = self.safe_dict(self.options, 'apiCredentials')
        if cachedCreds is not None:
            return cachedCreds
        # Check if credentials are provided directly(apiKey, secret, password)
        # This allows users to provide credentials directly instead of generating from privateKey
        if self.apiKey and self.secret and self.password:
            directCreds = {
                'apiKey': self.apiKey,
                'secret': self.secret,
                'passphrase': self.password,
            }
            self.set_api_creds(directCreds)
            return directCreds
        # If direct credentials not provided, check if privateKey is available for generation
        if self.privateKey is None:
            raise ArgumentsRequired(self.id + ' ensureApiCredentials() requires either: (1) apiKey + secret + password provided directly, or (2) privateKey to generate credentials')
        # Generate credentials lazily(similar to dYdX's retrieveCredentials pattern)
        # This is called automatically before authenticated requests
        creds = await self.create_or_derive_api_creds(params)
        self.set_api_creds(creds)
        return creds

    def get_api_credentials(self) -> dict:
        """
        Gets API credentials from cache or instance properties
        :returns dict} API credentials {apiKey, secret, password:
        """
        apiKey = self.apiKey
        secret = self.secret
        password = self.password
        # Check if credentials are already cached
        cachedCreds = self.safe_dict(self.options, 'apiCredentials')
        if cachedCreds is not None:
            apiKey = self.safe_string(cachedCreds, 'apiKey') or apiKey
            secret = self.safe_string(cachedCreds, 'secret') or secret
            password = self.safe_string(cachedCreds, 'passphrase') or password
        # If credentials are not available, check if privateKey is set
        # Only raise error if privateKey is set(meaning user wants authenticated requests)
        # This allows public requests to work even when privateKey is set but credentials not yet generated
        if not apiKey or not secret or not password:
            if self.privateKey is None:
                # No privateKey set - self should not happen if called from buildPrivateRequest
                raise ArgumentsRequired(self.id + ' getApiCredentials() called but no credentials available and no privateKey set. This should only be called for authenticated requests. Provide either: (1) apiKey + secret + password directly, or (2) privateKey to generate credentials.')
            # privateKey is set but credentials not generated yet - self is expected for lazy generation
            # Don't raise error here, ensureApiCredentials() handle it
            raise ArgumentsRequired(self.id + ' API credentials not generated. Credentials are automatically generated on first authenticated request, but privateKey is required. Alternatively, provide apiKey + secret + password directly.')
        return {'apiKey': apiKey, 'secret': secret, 'password': password}

    def build_request_path_and_payload(self, pathWithParams: str, method: str, queryParams: dict, body: str = None) -> dict:
        """
        Builds the request path and payload for signature
        :param str pathWithParams: path with parameters
        :param str method: HTTP method
        :param dict queryParams: query parameters
        :param str [body]: request body
        :returns dict} {requestPath, url, payload, body:
        """
        # Ensure path doesn't have double slashes(pathWithParams may already start with /)
        normalizedPath = pathWithParams if pathWithParams.startswith('/') else '/' + pathWithParams
        requestPath = normalizedPath
        url = requestPath
        payload = ''
        if method == 'GET':
            if queryParams:
                queryString = self.urlencode(queryParams)
                url += '?' + queryString
                payload = queryString
        else:
            # For POST/PUT/DELETE, body is part of the signature
            # Use deterministic JSON serialization(no spaces, compact) matching py-clob-client
            # json.dumps(body, separators=(",", ":"), ensure_ascii=False) produces compact JSON
            if body is None and queryParams:
                # json.dumpsby default produces compact JSON(no spaces)
                body = json.dumps(queryParams)
            # Serialize body deterministically if it's an object
            if body is not None and isinstance(body, dict):
                body = json.dumps(body)
            # Use body(quote replacement happens in createLevel2Signature)
            payload = str(body) if (body is not None and body != '') else ''
        return {'requestPath': requestPath, 'url': url, 'payload': payload, 'body': body}

    def create_level2_signature(self, timestamp: str, method: str, requestPath: str, body: str, secret: str) -> str:
        """
        Creates Level 2 authentication signature(HMAC-SHA256)

        https://docs.polymarket.com/developers/CLOB/authentication

        :param str timestamp: timestamp string
        :param str method: HTTP method
        :param str requestPath: request path
        :param str body: request body(serialized JSON string)
        :param str secret: API secret(base64 encoded, URL-safe)
        :returns str: URL-safe base64 encoded signature
        """
        # Create signature: HMAC-SHA256(timestamp + method + path + body, secret)
        # Based on Polymarket CLOB API L2 authentication(matches py-clob-client build_hmac_signature)
        # Use str(method) to preserve case(don't use toUpperCase())
        message = str(timestamp) + str(method) + str(requestPath)
        # Only add body if it exists and is not empty
        # NOTE: Replace single quotes with double quotes(matching py-clob-client behavior)
        # This is necessary to generate the same hmac message and typescript
        messageWithBody = message
        if body is not None and body != '':
            messageWithBody = message + str(body).replace("'", '"')
        # Generate HMAC and return URL-safe base64
        # Convert URL-safe base64 to standard base64(replace - with + and _ with /)
        secretBinary = self.base64_to_binary(str(secret).replace('-', '+').replace('_', '/'))
        hmacResult = self.hmac(self.encode(messageWithBody), secretBinary, hashlib.sha256, 'base64')
        return hmacResult.replace('+', '-').replace('/', '_')

    def create_level2_headers(self, apiKey: str, timestamp: str, signature: str, password: str) -> dict:
        """
        Creates Level 2 authentication headers

        https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/headers/headers.py

        :param str apiKey: API key
        :param str timestamp: timestamp string
        :param str signature: signature string
        :param str password: API passphrase
        :returns dict: Level 2 headers dictionary
        """
        authHeaders: dict = {
            'POLY_API_KEY': apiKey,
            'POLY_TIMESTAMP': timestamp,
            'POLY_SIGNATURE': signature,
            'POLY_PASSPHRASE': password,  # Passphrase is required for L2 authentication
            'Content-Type': 'application/json',
        }
        # Always include POLY_ADDRESS in Level 2 headers(matches GitHub issue  #190 fix)
        # Get wallet address from funder option, walletAddress property, or derive from privateKey
        walletAddress = self.safe_string(self.options, 'funder')
        if walletAddress is None and self.walletAddress is not None:
            walletAddress = self.walletAddress
        if walletAddress is None and self.privateKey is not None:
            # Derive wallet address from private key if not provided
            walletAddress = self.get_main_wallet_address()
        if walletAddress is not None:
            # Normalize and checksum the address(EIP-55)
            walletAddress = self.normalize_address(walletAddress)
            authHeaders['POLY_ADDRESS'] = walletAddress
        #  # Add signature type if provided(defaults to EOA from options)
        # signatureType = self.get_signature_type(params)
        # eoaSignatureType = self.safe_integer(self.safe_dict(self.options, 'signatureTypes', {}), 'EOA', 0)
        # if signatureType != eoaSignatureType:
        #     authHeaders['POLY_SIGNATURE_TYPE'] = str(signatureType)
        # }
        #  # Add chain ID(defaults to 137 for Polygon mainnet, 80001 for testnet)
        #  # chain_id: 137 = Polygon mainnet(default), 80001 = Polygon Mumbai testnet
        # chainId = self.safe_integer(self.options, 'chainId', 137)
        # authHeaders['POLY_CHAIN_ID'] = str(chainId)
        return authHeaders

    def build_private_request(self, baseUrl: str, pathWithParams: str, method: str, queryParams: dict, body: str = None, headers: dict = None) -> dict:
        """
        Builds a private(authenticated) request with L2 authentication
        :param str baseUrl: API base URL
        :param str pathWithParams: path with parameters
        :param str method: HTTP method
        :param dict queryParams: query parameters
        :param str [body]: request body
        :param dict [headers]: existing headers
        :returns dict: request object with url, method, body, and headers
        """
        # Ensure privateKey is set
        if self.privateKey is None:
            raise ArgumentsRequired(self.id + ' requires privateKey for authenticated requests')
        # Get API credentials - self will raise if credentials not generated
        # For lazy generation, ensureApiCredentials() should be called before self
        creds = self.get_api_credentials()
        timestamp = str(self.nonce())
        # Serialize body deterministically if it's an object(matching py-clob-client)
        # Use json.dumpswhich produces compact JSON by default(no spaces)
        # This matches: json.dumps(body, separators=(",", ":"), ensure_ascii=False)
        serializedBody: str = None
        if body is not None:
            if isinstance(body, dict):
                # Deterministic JSON: compact format(no spaces)
                serializedBody = json.dumps(body)
            else:
                serializedBody = str(body)
        elif queryParams and (method == 'POST' or method == 'PUT' or method == 'DELETE'):
            # If body is None but we have queryParams for POST/PUT/DELETE, serialize them
            serializedBody = json.dumps(queryParams)
        # Build request path and payload using the serialized body
        pathAndPayload = self.build_request_path_and_payload(pathWithParams, method, queryParams, serializedBody)
        requestPath = pathAndPayload['requestPath']
        requestUrl = pathAndPayload['url']
        # Use the serialized body for the actual request(exact string that will be sent)
        finalBody = serializedBody is not serializedBody if None else pathAndPayload['body']
        privateUrl = baseUrl + requestUrl
        # Create Level 2 signature: for GET requests, do NOT include query params in signature
        # For POST/PUT/DELETE, include the serialized body(not query params)
        # This matches py-clob-client: signature = timestamp + method + requestPath [+ body for non-GET]
        bodyForSignature = None if (method == 'GET') else serializedBody
        signature = self.create_level2_signature(timestamp, method, requestPath, bodyForSignature, creds['secret'])
        # Create Level 2 headers
        authHeaders = self.create_level2_headers(creds['apiKey'], timestamp, signature, creds['password'])
        # Merge with existing headers
        headers = self.build_default_headers(method, headers)
        headers = self.extend(headers, authHeaders)
        return {'url': privateUrl, 'method': method, 'body': finalBody, 'headers': headers}

    def sign(self, path, api: Any = [ 'clob', 'public' ], method='GET', params={}, headers=None, body=None):
        """
        Signs a request for authenticated endpoints

        https://docs.polymarket.com/developers/CLOB/authentication

        :param str path: API endpoint path
        :param str api: API type('public' or 'private')
        :param str method: HTTP method('GET', 'POST', etc.)
        :param dict params: Request parameters
        :param dict headers: Request headers
        :param str body: Request body
        :returns dict: Signed request with url, method, body, and headers
        """
        # Get API base URL
        baseUrl = self.get_api_base_url(params)
        # Build path with parameters
        pathWithParams = self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        # Remove api_type from query params's not part of the actual API request
        queryParams = self.omit(query, ['api_type'])
        # For public endpoints, no authentication needed
        # api is always an array like ['gamma', 'public'] or ['clob', 'private']
        # The second element is the access level(public/private)
        accessLevel = self.safe_string(api, 1, 'public')
        if accessLevel == 'public':
            return self.build_public_request(baseUrl, pathWithParams, method, queryParams, body, headers)
        # For private endpoints, use L2 authentication
        return self.build_private_request(baseUrl, pathWithParams, method, queryParams, body, headers)

    def handle_errors(self, code: int, reason: str, url: str, method: str, headers: dict, body: str, response: Any, requestHeaders: Any, requestBody: Any):
        if response is None:
            return None
        # Polymarket API errors
        if code >= 400:
            # Explicitly check for 401(Unauthorized) and raise AuthenticationError
            if code == 401:
                authFeedback = self.id + ' ' + method + ' ' + url + ' 401 ' + reason + ' ' + body
                raise AuthenticationError(authFeedback)
            # Try to parse error message from response first(can be JSON or text)
            # Check error message BEFORE status code to catch specific errors like "Order not found"
            # that may return 400 status but should raise OrderNotFound instead of BadRequest
            errorMessage = None
            errorData = None
            try:
                if isinstance(response, str):
                    errorMessage = response
                elif isinstance(response, dict):
                    errorMessage = self.safe_string(response, 'error')
                    if errorMessage is None:
                        errorMessage = self.safe_string(response, 'message')
                    if errorMessage is None:
                        # If no error/message field, use the whole response data
                        errorData = response
            except Exception as e:
                errorMessage = body
            feedback = self.id + ' ' + (errorMessage or body)
            if errorMessage is not None:
                # Try exact match first(e.g., "Order not found" -> OrderNotFound)
                self.throw_exactly_matched_exception(self.exceptions['exact'], errorMessage, feedback)
                # Then try broad match
                self.throw_broadly_matched_exception(self.exceptions['broad'], errorMessage, feedback)
                # If no match, fall through to status code check
            # Check HTTP status code(use throwExactlyMatchedException for proper type handling)
            # This handles cases where no specific error message is found in the response
            codeAsString = str(code)
            statusCodeFeedback = self.id + ' ' + method + ' ' + url + ' ' + codeAsString + ' ' + reason + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions['exact'], codeAsString, statusCodeFeedback)
            # If we reach here, no exception was thrown, so raise a generic error
            if errorData is not None:
                raise ExchangeError(self.id + ' ' + self.json(errorData))
            else:
                raise ExchangeError(feedback)
        return None
